dnl Process this file with autoconf to produce a configure script. -*-m4-*-

dnl %CopyrightBegin%
dnl
dnl Copyright Ericsson AB 1997-2017. All Rights Reserved.
dnl
dnl Licensed under the Apache License, Version 2.0 (the "License");
dnl you may not use this file except in compliance with the License.
dnl You may obtain a copy of the License at
dnl
dnl     http://www.apache.org/licenses/LICENSE-2.0
dnl
dnl Unless required by applicable law or agreed to in writing, software
dnl distributed under the License is distributed on an "AS IS" BASIS,
dnl WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
dnl See the License for the specific language governing permissions and
dnl limitations under the License.
dnl
dnl %CopyrightEnd%

dnl The string "FIXME convbreak" means that there is a break of
dnl autoconf convention that should be cleaned up.

AC_INIT(vsn.mk)
AC_PREREQ(2.59)

LM_PRECIOUS_VARS

if test "x$no_recursion" != "xyes" -a "x$OVERRIDE_CONFIG_CACHE" = "x"; then
    # We do not want to use a common cache!
    cache_file=/dev/null
fi

dnl How to set srcdir absolute is taken from the GNU Emacs distribution
#### Make srcdir absolute, if it isn't already.  It's important to
#### avoid running the path through pwd unnecessary, since pwd can
#### give you automounter prefixes, which can go away.
case "${srcdir}" in
  /* ) ;;
  . )
    ## We may be able to use the $PWD environment variable to make this
    ## absolute.  But sometimes PWD is inaccurate.
    ## Make sure CDPATH doesn't affect cd (in case PWD is relative).
    CDPATH=
    if test "${PWD}" != "" && test "`(cd ${PWD} ; sh -c pwd)`" = "`pwd`"  ;
    then
      srcdir="$PWD"
    else
      srcdir="`(cd ${srcdir}; pwd)`"
    fi
  ;;
  *  ) srcdir="`(cd ${srcdir}; pwd)`" ;;
esac

## Now, make sure that ERL_TOP is set and is the same as srcdir
##
if test -z "$ERL_TOP" || test ! -d $ERL_TOP ; then
  AC_MSG_ERROR(You need to set the environment variable ERL_TOP!)
fi
erl_top=${ERL_TOP}

AC_CONFIG_AUX_DIRS(${ERL_TOP}/erts/autoconf)

dnl ----------------------------------------------------------------------
dnl Figure out what system we are running on.
dnl ----------------------------------------------------------------------

#
# To configure for free source run ./configure --host=free_source
#
dnl
dnl AC_CANONICAL_HOST does not like free_source as a host specification,
dnl so we make a little special case.
dnl
if test "X$host" != "Xfree_source" -a "X$host" != "Xwin32"; then
    AC_CANONICAL_HOST
else
    host_os=$host
fi

if test "$cross_compiling" = "yes"; then
    CROSS_COMPILING=yes
else
    CROSS_COMPILING=no
fi
AC_SUBST(CROSS_COMPILING)

ERL_XCOMP_SYSROOT_INIT

AC_ISC_POSIX

AC_CONFIG_HEADER($host/config.h:$ERL_TOP/erts/config.h.in )
dnl ----------------------------------------------------------------------
dnl Optional features.
dnl ----------------------------------------------------------------------
ENABLE_ALLOC_TYPE_VARS=
AC_SUBST(ENABLE_ALLOC_TYPE_VARS)


AC_ARG_ENABLE(m64-build,
AS_HELP_STRING([--enable-m64-build],
               [build 64bit binaries using the -m64 flag to (g)cc]),
[ case "$enableval" in
    no) enable_m64_build=no ;;
    *)  enable_m64_build=yes ;;
  esac
],enable_m64_build=no)

AC_ARG_ENABLE(m32-build,
AS_HELP_STRING([--enable-m32-build],
               [build 32bit binaries using the -m32 flag to (g)cc]),
[ case "$enableval" in
    no) enable_m32_build=no ;;
    *)	enable_m32_build=yes ;;
  esac
],enable_m32_build=no)

dnl Magic test for clearcase.
OTP_RELEASE=
if test "${ERLANG_COMMERCIAL_BUILD}" != ""; then
	OTP_EXTRA_FLAGS=-DOTP_RELEASE
	OTP_RELEASE=yes
else
	OTP_EXTRA_FLAGS=
fi
AC_SUBST(OTP_RELEASE)

AC_MSG_CHECKING([OTP release])
[SYSTEM_VSN=`cat $ERL_TOP/OTP_VERSION | sed "s|\([0-9]*\).*|\1|"`]
AC_MSG_RESULT([$SYSTEM_VSN])
AC_SUBST(SYSTEM_VSN)

AC_MSG_CHECKING([OTP version])
[OTP_VERSION=`cat $ERL_TOP/OTP_VERSION`]
AC_MSG_RESULT([$OTP_VERSION])
AC_SUBST(OTP_VERSION)

if test X${enable_m64_build} = Xyes; then
	case $CFLAGS in
		*-m64*)
			;;
		*)
			CFLAGS="-m64 $CFLAGS"
			;;
	esac
else
	if test X${enable_m32_build} = Xyes;
	then
		case $CFLAGS in
		    *-m32*)
			    ;;
		    *)
			    CFLAGS="-m32 $CFLAGS"
			    ;;
		esac ;
	fi
fi

dnl ----------------------------------------------------------------------
dnl Checks for programs.
dnl ----------------------------------------------------------------------

AC_PROG_CC
AC_SUBST(GCC)

dnl ---------------------------------------------------------------------
dnl Special stuff regarding CFLAGS and details in the environment...
dnl ---------------------------------------------------------------------

dnl NOTE: CPPFLAGS will be included in CFLAGS at the end
case $host_os in
    linux*) CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE";; 
    win32)
	# The ethread library requires _WIN32_WINNT of at least 0x0403.
	# -D_WIN32_WINNT=* from CPPFLAGS is saved in ETHR_DEFS.
	CPPFLAGS="$CPPFLAGS -D_WIN32_WINNT=0x0600 -DWINVER=0x0600"
	;;
    *)
	;;
esac


LM_WINDOWS_ENVIRONMENT
	
dnl
dnl Flags to the C compiler
dnl
dnl Make sure we find config.h
dnl

extra_flags="-I${ERL_TOP}/erts/$host $OTP_EXTRA_FLAGS"
CFLAGS="$CFLAGS $extra_flags"
DEBUG_CFLAGS="-g $CPPFLAGS $extra_flags $DEBUG_CFLAGS"
DEBUG_FLAGS=-g

dnl
dnl Adjust DEBUG_CFLAGS to match CFLAGS in terms of -m
dnl

case $CFLAGS in
	*-m64*)
		case $DEBUG_CFLAGS in
			*-m64*)
				;;
			*)
				DEBUG_CFLAGS="-m64 $DEBUG_CFLAGS"
				;;
		esac
		;;
	*-m32*)
		case $DEBUG_CFLAGS in
			*-m32*)
				;;
			*)
				DEBUG_CFLAGS="-m32 $DEBUG_CFLAGS"
				;;
		esac
		;;
	*)
		;;
esac



CFLAG_RUNTIME_LIBRARY_PATH="-Wl,-R"
case $host_os in
  darwin*)
	CFLAG_RUNTIME_LIBRARY_PATH=
	;;
  win32)
	CFLAG_RUNTIME_LIBRARY_PATH=
	;;
  osf*)
	CFLAG_RUNTIME_LIBRARY_PATH="-Wl,-rpath,"
	;;
  *)
	;;
esac

lfs_conf=ok
lfs_source=none
if test "${LFS_CFLAGS+set}" = "set" || \
   test "${LFS_LDFLAGS+set}" = "set" || \
   test "${LFS_LIBS+set}" = "set"; then
    lfs_source=user
else
   LM_CHECK_GETCONF
   test "$GETCONF" = "false" || lfs_source=getconf
fi

if test "$lfs_source" = "none"; then
    AC_MSG_WARN([Do not know how to check for large file support flags; no getconf is available])
else
    for var in CFLAGS LDFLAGS LIBS; do
	AC_MSG_CHECKING([for large file support $var])
	if test $lfs_source = user; then
	    eval "lfs_val=\"\$LFS_$var\""
	else
	    eval "lfs_var=LFS_$var"
	    lfs_val=`$GETCONF $lfs_var 2>/dev/null` || lfs_conf=failed
	    if test $lfs_conf = failed; then
		AC_MSG_RESULT([failed])
		break
	    fi
	    eval "$lfs_var=\"$lfs_val\""
	fi
	test "$lfs_val" != "" || lfs_val=none
	AC_MSG_RESULT([$lfs_val])
    done
    if test $lfs_conf = failed; then
	AC_MSG_WARN([Check for large file support flags failed; $GETCONF failed])
    else
	CFLAGS="$CFLAGS $LFS_CFLAGS"
	DEBUG_CFLAGS="$DEBUG_CFLAGS $LFS_CFLAGS"
	LDFLAGS="$LDFLAGS $LFS_LDFLAGS"
	LIBS="$LIBS $LFS_LIBS"
    fi
fi

if test "x$GCC" = xyes; then
  # Treat certain GCC warnings as errors
  LM_TRY_ENABLE_CFLAG([-Werror=return-type], [WERRORFLAGS])
  LM_TRY_ENABLE_CFLAG([-Werror=implicit], [WERRORFLAGS])
  LM_TRY_ENABLE_CFLAG([-Werror=undef], [WERRORFLAGS])

  # until the emulator can handle this, I suggest we turn it off!
  #WFLAGS="-Wall -Wshadow -Wcast-qual -Wmissing-declarations"
  WFLAGS="-Wall -Wstrict-prototypes"

  case "$host_cpu" in
    tile*)
      # tile-gcc is a bit stricter with -Wmissing-prototypes than other gccs,
      # and too strict for our taste.
      ;;
    *)
      WFLAGS="$WFLAGS -Wmissing-prototypes";;
  esac

  saved_CFLAGS=$CFLAGS
  CFLAGS="$CFLAGS -Wdeclaration-after-statement"
  AC_TRY_COMPILE([],[;], warn_decl_after_st=true, warn_decl_after_st=false)
  if test "X$warn_decl_after_st" = "Xtrue"; then
    WFLAGS="$WFLAGS -Wdeclaration-after-statement"
  fi
  CFLAGS=$saved_CFLAGS
else
  WFLAGS=""
  WERRORFLAGS=""
fi
dnl DEBUG_FLAGS is obsolete (I hope)
AC_SUBST(DEBUG_FLAGS)
AC_SUBST(DEBUG_CFLAGS)
AC_SUBST(WFLAGS)
AC_SUBST(WERRORFLAGS)
AC_SUBST(CFLAG_RUNTIME_LIBRARY_PATH)

## Check if we can do profile guided optimization of beam_emu
LM_CHECK_ENABLE_CFLAG([-fprofile-generate -Werror],[PROFILE_GENERATE])
LM_CHECK_ENABLE_CFLAG([-fprofile-use -Werror],[PROFILE_USE])

## Check if this is clang
LM_CHECK_ENABLE_CFLAG([-fprofile-instr-generate -Werror],[PROFILE_INSTR_GENERATE])
if test "X$PROFILE_INSTR_GENERATE" = "Xtrue"; then
   # It was clang, now we also have to check if we have llvm-profdata and that
   # we can link programs with -fprofile-instr-use
   saved_CFLAGS=$CFLAGS;
   CFLAGS="-fprofile-instr-generate -Werror $saved_CFLAGS"
   AC_RUN_IFELSE([AC_LANG_PROGRAM([],[])],
     [AC_CHECK_PROGS([LLVM_PROFDATA], [llvm-profdata])
      AC_CHECK_PROGS([XCRUN], [xcrun])
      if test "X$XCRUN" != "X" -a "X$LLVM_PROFDATA" = "X"; then
        AC_MSG_CHECKING([for $XCRUN llvm-profdata])
        if $XCRUN llvm-profdata --help 2>& AS_MESSAGE_LOG_FD >& AS_MESSAGE_LOG_FD; then
          LLVM_PROFDATA="$XCRUN llvm-profdata"
          AC_MSG_RESULT([yes])
        else
          AC_MSG_RESULT([no])
        fi
      fi
      AC_SUBST(LLVM_PROFDATA)
      if test "X$LLVM_PROFDATA" != "X"; then
        CFLAGS="-fprofile-instr-use=default.profdata -Werror $saved_CFLAGS";
        $LLVM_PROFDATA merge -output=default.profdata *.profraw;
        AC_MSG_CHECKING([whether gcc accepts -fprofile-instr-use=default.profdata -Werror])
        AC_COMPILE_IFELSE([],
          [AC_MSG_RESULT([yes])
           PROFILE_INSTR_USE=true],
          [AC_MSG_RESULT([no])
           PROFILE_INSTR_USE=false])
        rm -f default.profdata
      fi],
     [])
   rm -f *.profraw
   CFLAGS=$saved_CFLAGS;
fi

#LM_CHECK_ENABLE_CFLAG([-fprofile-use -fprofile-correction -Werror],[PROFILE_CORRECTION]) ## ???

AC_CHECK_SIZEOF(void *) # Needed for ARCH and smp checks below
if test "x$ac_cv_sizeof_void_p" = x8; then
  AC_SUBST(EXTERNAL_WORD_SIZE, 64)
else
  AC_SUBST(EXTERNAL_WORD_SIZE, 32)
fi

dnl
dnl Figure out operating system and cpu architecture
dnl

if test "x$host_alias" != "x"; then
    chk_opsys_=$host_os
else
    chk_opsys_=`uname -s`
    if test "x$chk_opsys_" = "xSunOS"; then
	chk_opsys_=$chk_opsys_`uname -r`
    fi
fi
case $chk_opsys_ in
    win32)			OPSYS=win32;;
    solaris2.*|SunOS5.*)	OPSYS=sol2;;
    linux*|Linux)		OPSYS=linux;;
    darwin|Darwin)		OPSYS=darwin;;
    freebsd|FreeBSD)		OPSYS=freebsd;;
    *)				OPSYS=noopsys
esac

AC_SUBST(OPSYS)

LM_HARDWARE_ARCH

dnl Check consistency of os and darwin-switches


dnl Take care of LDFLAGS on darwin, and disable common_test as it
dnl has a build/configure system re rx-lib that is not compatible
dnl First remove common_tests skip file.

dnl Adjust LDFLAGS to allow 64bit linkage on DARWIN
case $ARCH-$OPSYS in
	amd64-darwin*)
		AC_MSG_NOTICE([Adjusting LDFLAGS to cope with 64bit Darwin])
		case $LDFLAGS in
			*-m64*)
				;;
			*)
				LDFLAGS="-m64 $LDFLAGS"
			;;
		esac
		;;
	*-darwin*)
		case $LDFLAGS in
			*-m32*)
				;;
			*)
				LDFLAGS="-m32 $LDFLAGS"
				;;
		esac
		;;
	*)
		if test X${enable_m64_build} = Xyes; then
			AC_MSG_NOTICE([Adjusting LDFLAGS to use -m64])
			case $LDFLAGS in
				*-m64*)
					;;
				*)
					LDFLAGS="-m64 $LDFLAGS"
				;;
			esac
		fi;
		if test X${enable_m32_build} = Xyes; then
			AC_MSG_NOTICE([Adjusting LDFLAGS to use -m32]) ;
			case $LDFLAGS in
				*-m32*)
					;;
				*)
					LDFLAGS="-m32 $LDFLAGS"
				;;
			esac ;
		fi
		;;
esac

AC_MSG_CHECKING(if VM has to be linked with Carbon framework)
case $ARCH-$OPSYS in
	*-darwin*)
  		LIBCARBON="-framework Carbon -framework Cocoa"
		AC_MSG_RESULT([yes])
		;;
	*)
		LIBCARBON=
		AC_MSG_RESULT([no])
		;;
esac
	
AC_SUBST(LIBCARBON)

_search_path=/bin:/usr/bin:/usr/local/bin:$PATH

AC_PATH_PROG(RM, rm, false, $_search_path)
if test "$ac_cv_path_RM" = false; then
  AC_MSG_ERROR([No 'rm' command found])
fi

AC_PATH_PROG(MKDIR, mkdir, false, $_search_path)
if test "$ac_cv_path_MKDIR" = false; then
  AC_MSG_ERROR([No 'mkdir' command found])
fi

AC_PATH_PROG(CP, cp, false, $_search_path)
if test "$ac_cv_path_CP" = false; then
  AC_MSG_ERROR([No 'cp' command found])
fi

_search_path=


# Remove old configuration information.
# Next line should be placed after AC_PATH_PROG(RM, ...), but before
# first output to CONN_INFO. So this is just the right place.
$RM -f "$ERL_TOP/erts/CONF_INFO"

dnl Check if we should/can build a sharing-preserving emulator
AC_MSG_CHECKING(if we are building a sharing-preserving emulator)
if test "$enable_sharing_preserving" = "yes"; then
        AC_DEFINE(SHCOPY, [1],
		  [Define if building a sharing-preserving emulator])
	AC_MSG_RESULT([yes])
else
	AC_MSG_RESULT([no])
fi


dnl some tests below will call this if we haven't already - and autoconf
dnl can't handle those tests being done conditionally at runtime
AC_PROG_CPP

AC_PROG_RANLIB

AC_PROG_YACC
LM_PROG_PERL5
if test "$ac_cv_path_PERL" = false; then
  AC_MSG_ERROR([Perl version 5 is required to build the emulator!])
fi
AC_PROG_LN_S


AC_CHECK_TOOL([AR], [ar], [false])
if test "$ac_cv_prog_AR" = false; then
  AC_MSG_ERROR([No 'ar' command found in PATH])
fi

#
# Get programs needed for building the documentation 
#

## Delete previous failed configure results
if test -f doc/CONF_INFO; then
   $RM doc/CONF_INFO
fi

AC_CHECK_PROGS(XSLTPROC, xsltproc)
if test -z "$XSLTPROC"; then
  echo "xsltproc" >> doc/CONF_INFO
  AC_MSG_WARN([No 'xsltproc' command found: the documentation cannot be built])
fi

AC_CHECK_PROGS(FOP, fop)
if test -z "$FOP"; then
  FOP="$ERL_TOP/make/fakefop"
  echo "fop" >> doc/CONF_INFO
  AC_MSG_WARN([No 'fop' command found: going to generate placeholder PDF files])
fi

AC_CHECK_PROGS(XMLLINT, xmllint)
if test -z "$XMLLINT"; then
  echo "xmllint" >> doc/CONF_INFO
  AC_MSG_WARN([No 'xmllint' command found: can't run the xmllint target for the documentation])
fi

dnl
dnl We can live with Solaris /usr/ucb/install
dnl
case $host in
  *-*-solaris*|free_source)
    if test -x /usr/ucb/install; then
      INSTALL="/usr/ucb/install -c"
    fi
    ;;
  *)
    ;;
esac
AC_PROG_INSTALL
LM_PROG_INSTALL_DIR

case $host_os in
	darwin*)
		dnl Need to preserve modification time on archives;
		dnl otherwise, ranlib has to be run on archives
		dnl again after installation.
		INSTALL_DATA="$INSTALL_DATA -p";;
	*)
		;;
esac

dnl
dnl Fix for Tilera install permissions
dnl

case $build in
	*tile*)
		INSTALL_PROGRAM="$INSTALL_PROGRAM -m755"
		INSTALL_SCRIPT="$INSTALL_SCRIPT -m755"
		;;
	*)
		;;
esac

dnl ----------------------------------------------------------------------
dnl Misc. things (some of them should go away)
dnl ----------------------------------------------------------------------

dnl
dnl An attempt to allow cross compiling. This is not the right way,
dnl nor does it work currently. Some makefiles still needs these
dnl variables, so we leave them in for now.
dnl
HCC='$(CC)'         AC_SUBST(HCC)
HCFLAGS=""          AC_SUBST(HCFLAGS)
HCFLAGS="$HCFLAGS -I${ERL_TOP}/erts/$host"
vxworks_reclaim=""  AC_SUBST(vxworks_reclaim)

dnl We want to use $(CC) as linker for the emulator regardless of
dnl what the user say. This might not be the right way to do it, but
dnl for now that is the way we do it.
USER_LD=$LD
USER_LDFLAGS="$LDFLAGS"
LD='$(CC)'
case $host_os in
     darwin*)
	saved_LDFLAGS="$LDFLAGS"
	LDFLAGS="$LDFLAGS -Wl,-no_weak_imports"
	AC_TRY_LINK([],[],
		[
			LD_MAY_BE_WEAK=no
		],
		[
			LD_MAY_BE_WEAK=yes
			LDFLAGS="$saved_LDFLAGS"
		]);;
    *)
	LD_MAY_BE_WEAK=no;;
esac

AC_SUBST(LD)

LDFLAG_RUNTIME_LIBRARY_PATH="$CFLAG_RUNTIME_LIBRARY_PATH"
AC_SUBST(LDFLAG_RUNTIME_LIBRARY_PATH)

dnl Check for cygwin and object/exe files extension
dnl AC_CYGWIN is deprecated
AC_EXEEXT
AC_OBJEXT

dnl This is the os flavour, should be unix, ose, vxworks or win32
case $host in
   win32)
      ERLANG_OSTYPE=win32 ;;
   *)
      ERLANG_OSTYPE=unix ;;
esac

AC_SUBST(ERLANG_OSTYPE)

# Check how to export functions from the emulator executable, needed
# when dynamically loaded drivers are loaded (so that they can find
# emulator functions).
# OS'es with ELF executables using the GNU linker (Linux and recent *BSD,
# in rare cases Solaris) typically need '-Wl,-export-dynamic' (i.e. pass
# -export-dynamic to the linker - also known as -rdynamic and some other
# variants); some sysVr4 system(s) instead need(s) '-Wl,-Bexport'.
# AIX 4.x (perhaps only for x>=2) wants -Wl,-bexpall,-brtl and doesn't
# reliably return an error for others, thus we separate it out.
# Otherwise we assume that if the linker accepts the flag, it is needed.
AC_MSG_CHECKING(for extra flags needed to export symbols)
DEXPORT=""
case $host_os in
	aix4*)
		DEXPORT=-Wl,-bexpall,-brtl
	;;
	bsdi*)
    		DEXPORT="-rdynamic " 
    	;;
	win32)
    		DEXPORT="" 
    	;;
	*)
		save_ldflags="$LDFLAGS"
		LDFLAGS=-Wl,-export-dynamic
		AC_TRY_LINK(,,[DEXPORT=-Wl,-export-dynamic], [
			LDFLAGS=-Wl,-Bexport
			AC_TRY_LINK(,,[DEXPORT=-Wl,-Bexport],
				AC_MSG_RESULT(none))])
		LDFLAGS="$save_ldflags"
	;;
esac
AC_SUBST(DEXPORT)
case "x$DEXPORT" in
	"x")
		AC_MSG_RESULT([none]);;
	*)
		AC_MSG_RESULT([$DEXPORT]);;
esac

# Check for Solaris/ultrasparc /dev/perfmon interface
# (also needs gcc specific asm instructions)
case "${host}:${GCC}" in
  sparc-*-solaris*:yes)
    AC_DEFINE(HAVE_SOLARIS_SPARC_PERFMON,[1],
	[define if you have the Solaris/ultrasparc /dev/perfmon interface])
    ;;
  *)
    ;;
esac


dnl ----------------------------------------------------------------------
dnl Checks for libraries.
dnl ----------------------------------------------------------------------

AC_CHECK_LIB(m, sin)
AC_CHECK_LIB(dl, dlopen)
AC_CHECK_LIB(inet, main)
AC_CHECK_LIB(util, openpty)

dnl Try to find a thread library.
dnl
dnl ETHR_LIB_NAME, ETHR_LIBS, ETHR_X_LIBS, ETHR_THR_LIB_BASE and ETHR_DEFS
dnl are set by ERL_FIND_ETHR_LIB
ERL_FIND_ETHR_LIB

if test "X$ETHR_LIB_NAME" = "X"; then
   AC_MSG_ERROR([cannot build emulator since no thread library was found])
fi

TYPES=opt

DIRTY_SCHEDULER_TEST=$enable_dirty_schedulers_test
AC_SUBST(DIRTY_SCHEDULER_TEST)
test $DIRTY_SCHEDULER_TEST != yes || {
    test -f "$ERL_TOP/erts/CONF_INFO" || echo "" > "$ERL_TOP/erts/CONF_INFO"
    cat >> $ERL_TOP/erts/CONF_INFO <<EOF

                 WARNING:
                   Dirty Scheduler Test has been enabled. This
                   feature is for debugging purposes only.
                   Poor performance as well as strange system
                   characteristics is expected!

EOF
}

test "X$smp_require_native_atomics" = "Xyes" &&
     AC_DEFINE(ETHR_SMP_REQUIRE_NATIVE_IMPLS, 1, [Define if you want to enable check for native ethread implementations])

case "$ethr_have_native_atomics-$smp_require_native_atomics-$ethr_have_native_spinlock" in
  yes-*)
	if test "$ethr_native_atomic_implementation" = "gcc_sync"; then
	    test -f "$ERL_TOP/erts/CONF_INFO" ||
		echo "" > "$ERL_TOP/erts/CONF_INFO"
	    cat >> $ERL_TOP/erts/CONF_INFO <<EOF

                 WARNING:
                   Only gcc's __sync_* builtins available for
                   atomic memory access. This will cause lots
                   of expensive and unnecessary memory barrier
                   instructions to be issued which will make
                   the performance of the runtime system
                   suffer. You are *strongly* advised to
                   upgrade to a gcc version that supports the
                   __atomic_* builtins (at least gcc version
                   4.7) or build with libatomic_ops. See the
                   "Atomic Memory Operations and the VM"
		   chapter of \$ERL_TOP/HOWTO/INSTALL.md for
                   more information.

EOF
	fi
	;;

  no-yes-*)
	AC_MSG_ERROR([No native atomic implementation found. See the \"Atomic Memory Operations and the VM\" chapter of \$ERL_TOP/HOWTO/INSTALL.md for more information.])
	;;

  no-no-yes)

	test -f "$ERL_TOP/erts/CONF_INFO" ||
	    echo "" > "$ERL_TOP/erts/CONF_INFO"
	cat >> $ERL_TOP/erts/CONF_INFO <<EOF

                 No native atomic implementation available.
                 Fallbacks implemented using spinlocks will be
                 used. Note that the performance of the SMP
                 runtime system will suffer immensely due to
		 this.

EOF
	;;

  no-no-no)
	test -f "$ERL_TOP/erts/CONF_INFO" ||
	    echo "" > "$ERL_TOP/erts/CONF_INFO"
	cat >> "$ERL_TOP/erts/CONF_INFO" <<EOF

                 No native atomic implementation, nor no native
                 spinlock implementation available. Fallbacks
                 implemented using mutexes will be used. Note
                 that the performance of the SMP runtime system
                 will suffer immensely due to this.

EOF
	;;

esac
AC_SUBST(TYPES)

AC_CHECK_FUNCS([posix_fadvise closefrom])
AC_CHECK_HEADERS([linux/falloc.h])
dnl * Old glibcs have broken fallocate64(). Make sure not to use it.
AC_CACHE_CHECK([whether fallocate() works],i_cv_fallocate_works,[
    AC_TRY_LINK([
        #include <stdio.h>
        #include <stdlib.h>
        #include <fcntl.h>
        #include <unistd.h>
	#include <fcntl.h>
	#include <linux/falloc.h>
	],
        [	            
	int fd = creat("conftest.temp", 0600);
        fallocate(fd, FALLOC_FL_KEEP_SIZE,(off_t)  1024,(off_t)  1024);
    	], i_cv_fallocate_works=yes, i_cv_fallocate_works=no)
])
if test $i_cv_fallocate_works = yes; then
   AC_DEFINE(HAVE_FALLOCATE, 1, Define if you have a working fallocate())
fi

dnl * Old glibcs have broken posix_fallocate(). Make sure not to use it.
dnl * It may also be broken in AIX.
AC_CACHE_CHECK([whether posix_fallocate() works],i_cv_posix_fallocate_works,[
    AC_TRY_RUN([
        #if !defined(__sun) && !defined(__sun__)
        #define _XOPEN_SOURCE 600
        #endif
        #include <stdio.h>
        #include <stdlib.h>
        #include <fcntl.h>
        #include <unistd.h>
        #if defined(__GLIBC__) && (__GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 7))
            possibly broken posix_fallocate
        #endif
        int main() {
            int fd = creat("conftest.temp", 0600);
            int ret;
            if (-1 == fd) {
               perror("creat()");
               return 2;
            }
            ret = posix_fallocate(fd, 1024, 1024) < 0 ? 1 : 0;
            unlink("conftest.temp");
            return ret;
        }
    ], [
        i_cv_posix_fallocate_works=yes
    ], [
        i_cv_posix_fallocate_works=no
    ], [
        i_cv_posix_fallocate_works=no
    ])
])
if test $i_cv_posix_fallocate_works = yes; then
   AC_DEFINE(HAVE_POSIX_FALLOCATE,, Define if you have a working posix_fallocate())
fi

#
# EMU_THR_LIB_NAME, EMU_THR_LIBS, EMU_THR_X_LIBS, and EMU_THR_DEFS is
# used by the emulator, and can (but should not) be used by applications
# that only require thread support when the emulator has thread support.
# Other applications should use ETHR_LIB_NAME, ETHR_LIBS, ETHR_X_LIBS,
# and ETHR_DEFS.
#

EMU_THR_LIB_NAME=
EMU_THR_X_LIBS=
EMU_THR_LIBS=
EMU_THR_DEFS=

# Threads enabled for emulator
EMU_THR_LIB_NAME=$ETHR_LIB_NAME
EMU_THR_X_LIBS=$ETHR_X_LIBS
EMU_THR_LIBS=$ETHR_LIBS
EMU_THR_DEFS=$ETHR_DEFS
ENABLE_ALLOC_TYPE_VARS="$ENABLE_ALLOC_TYPE_VARS threads"
AC_MSG_CHECKING(whether lock checking should be enabled)
AC_MSG_RESULT($enable_lock_check)
if test "x$enable_lock_check" != "xno"; then
    EMU_THR_DEFS="$EMU_THR_DEFS -DERTS_ENABLE_LOCK_CHECK"
fi

AC_MSG_CHECKING(whether lock counters should be enabled)
AC_MSG_RESULT($enable_lock_count)
if test "x$enable_lock_count" != "xno"; then
    TYPES="$TYPES lcnt"
fi

case $host_os in
    linux*)
	AC_MSG_CHECKING([whether dlopen() needs to be called before first call to dlerror()])
	if test "x$ETHR_THR_LIB_BASE_TYPE" != "xposix_nptl"; then
	    AC_DEFINE(ERTS_NEED_DLOPEN_BEFORE_DLERROR,[1],
		[Define if dlopen() needs to be called before first call to dlerror()])
		AC_MSG_RESULT(yes)
	else
		AC_MSG_RESULT(no)
	fi
	;;
    *)
	;;
esac

# Remove -D_WIN32_WINNT*, -DWINVER* and -D_GNU_SOURCE from EMU_THR_DEFS
# (defined in CFLAGS). Note that we want to keep these flags
# in ETHR_DEFS, but not in EMU_THR_DEFS.
new_emu_thr_defs=
for thr_def in $EMU_THR_DEFS; do
    case $thr_def in
	-D_GNU_SOURCE*|-D_WIN32_WINNT*|-DWINVER*)
	    ;;
	*)
	    new_emu_thr_defs="$new_emu_thr_defs $thr_def"
	    ;;
    esac
done
EMU_THR_DEFS=$new_emu_thr_defs

AC_SUBST(EMU_THR_LIB_NAME)
AC_SUBST(EMU_THR_X_LIBS)
AC_SUBST(EMU_THR_LIBS)
AC_SUBST(EMU_THR_DEFS)

if test "x$enable_lock_check" = "xno"; then
    EMU_LOCK_CHECKING=no
else
    EMU_LOCK_CHECKING=yes
fi

AC_SUBST(EMU_LOCK_CHECKING)

ERL_INTERNAL_LIBS

dnl THR_LIBS and THR_DEFS are only used by odbc
THR_LIBS=$ETHR_X_LIBS
THR_DEFS=$ETHR_DEFS

AC_SUBST(THR_LIBS)
AC_SUBST(THR_DEFS)

dnl ----------------------------------------------------------------------
dnl Try to figure out where to get the termcap functions from.
dnl We use tgetent(), tgetflag(), tgetnum(), tgetstr() and tputs()
dnl ----------------------------------------------------------------------

TERMCAP_LIB=

if test "x$with_termcap" != "xno" &&
   test "X$host" != "Xwin32"; then
    # try these libs
    termcap_libs="tinfo ncurses curses termcap termlib"

    for termcap_lib in $termcap_libs; do
	AC_CHECK_LIB($termcap_lib, tgetent, TERMCAP_LIB="-l$termcap_lib")
	if test "x$TERMCAP_LIB" != "x"; then
	    break
	fi
    done

    if test "x$TERMCAP_LIB" = "x"; then
	AC_MSG_ERROR([No curses library functions found])
    fi
fi

AC_SUBST(TERMCAP_LIB)

if test "x$TERMCAP_LIB" != "x"; then

	AC_DEFINE(HAVE_TERMCAP, 1, [Define if termcap functions exists])
fi

if test "X$host" != "Xwin32"; then
    AC_MSG_CHECKING(for wcwidth)
    AC_TRY_LINK([#include <wchar.h>], [wcwidth(0);],
                have_wcwidth=yes, have_wcwidth=no)
    if test $have_wcwidth = yes; then
        AC_MSG_RESULT([yes])
        AC_DEFINE(HAVE_WCWIDTH, [1],
                  [Define to 1 if you have a `wcwidth' function.])
    fi
fi

dnl
dnl This test kindly borrowed from Tcl
dnl
#--------------------------------------------------------------------
#	Check for the existence of the -lsocket and -lnsl libraries.
#	The order here is important, so that they end up in the right
#	order in the command line generated by make.  Here are some
#	special considerations:
#	1. Use "connect" and "accept" to check for -lsocket, and
#	   "gethostbyname" to check for -lnsl.
#	2. Use each function name only once:  can't redo a check because
#	   autoconf caches the results of the last check and won't redo it.
#	3. Use -lnsl and -lsocket only if they supply procedures that
#	   aren't already present in the normal libraries.  This is because
#	   IRIX 5.2 has libraries, but they aren't needed and they're
#	   bogus:  they goof up name resolution if used.
#	4. On some SVR4 systems, can't use -lsocket without -lnsl too.
#	   To get around this problem, check for both libraries together
#	   if -lsocket doesn't work by itself.
#--------------------------------------------------------------------

tk_oldLibs=$LIBS
erl_checkBoth=0
SOCKET_LIBS=""
AC_CHECK_FUNC(connect, erl_checkSocket=0, erl_checkSocket=1)
if test "$erl_checkSocket" = 1; then
    AC_CHECK_LIB(socket, main, SOCKET_LIBS="-lsocket", erl_checkBoth=1)
fi

if test "$erl_checkBoth" = 1; then
    LIBS="$LIBS -lsocket -lnsl"
    AC_CHECK_FUNC(accept, SOCKET_LIBS="-lsocket -lnsl")
fi

LIBS="$tk_oldLibs $SOCKET_LIBS"
AC_CHECK_FUNC(gethostbyname, , AC_CHECK_LIB(nsl, main, [SOCKET_LIBS="$SOCKET_LIBS -lnsl"]))
AC_CHECK_FUNC(gethostbyname_r,have_gethostbyname_r=yes)

LIBS="$tk_oldLibs $SOCKET_LIBS"

AC_SUBST(SOCKET_LIBS)

dnl
dnl These gethostbyname thingies use old style AC_DEFINE for BC with ancient 
dnl autoconf...
dnl 
if test "$have_gethostbyname_r" = yes; then
	# OK, so we have gethostbyname_r() - but do we know how to call it...?
	# (if not, HAVE_GETHOSTBYNAME_R will not be defined at all)
	case $host_os in
		solaris2*)
			AC_DEFINE(HAVE_GETHOSTBYNAME_R, GHBN_R_SOLARIS,
				[Define to flavour of gethostbyname_r])
		;;
		aix4*)
			# AIX version also needs "struct hostent_data" defn
			AC_TRY_COMPILE([#include <netdb.h>],
				[struct hostent_data hd;],
				AC_DEFINE(HAVE_GETHOSTBYNAME_R, GHBN_R_AIX,
				    [Define to flavour of gethostbyname_r]))
		;;
		*)
			AC_EGREP_CPP(^yes$,[
#include <stdio.h>
#ifdef __GLIBC__
yes
#endif
			  ], AC_DEFINE(HAVE_GETHOSTBYNAME_R, GHBN_R_GLIBC,
				[Define to flavour of gethostbyname_r]))
		;;
	esac
fi

AC_MSG_CHECKING(for working posix_openpt implementation)
AC_TRY_LINK([
#define _XOPEN_SOURCE 600 
#include <stdlib.h>
#include <fcntl.h>
],
[
    int mfd = posix_openpt(O_RDWR);
    ptsname(mfd);
    grantpt(mfd);
    unlockpt(mfd);
    return mfd;
], working_posix_openpt=yes, working_posix_openpt=no)

if test "X$working_posix_openpt" = "Xyes"; then
    AC_DEFINE(HAVE_WORKING_POSIX_OPENPT, [1],
	      [Define if you have a working posix_openpt implementation])
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

dnl Check for usage of sockaddr_in in netdb.h
dnl somewhat ugly check, I check for presence of the string and that 
dnl compilation works. If either fails I assume it's not needed.
dnl Seems only to be needed on a patched version of solaris2.5.1, with
dnl netdb.h  version  1.18.
AC_MSG_CHECKING([if netdb.h requires netinet/in.h to be previously included])
AC_EGREP_CPP(sockaddr_in, 
	     [#include <netdb.h>],
	     AC_TRY_COMPILE([#include <netinet/in.h>
			     #include <netdb.h>], 
			    [return 0;],
			    need_in_h=yes, 
                            need_in_h=no),
             need_in_h=no)

if test $need_in_h = yes; then
	AC_DEFINE(NETDB_H_NEEDS_IN_H,[1],
		[Define if netdb.h needs struct sockaddr_in ans in.h CAN be included before])
	AC_MSG_RESULT(yes)
else
	AC_MSG_RESULT(no)
fi

dnl Check for type socklen_t
dnl
AC_MSG_CHECKING([for socklen_t])
AC_TRY_COMPILE( [#include <sys/socket.h>], 
		[socklen_t test;],
		have_socklen_t=yes, 
                have_socklen_t=no),

if test $have_socklen_t = yes; then
	AC_DEFINE(HAVE_SOCKLEN_T,[1],[Define if we have socklen_t])
	AC_MSG_RESULT(yes)
else
	AC_MSG_RESULT(no)
fi


dnl h_errno isn't always declared in netdb.h, and with some definitions
dnl (e.g. function call for thread-safe) a simple 'extern int' may conflict
dnl (we do assume that h_errno exists at all...)
AC_CACHE_CHECK([for h_errno declaration in netdb.h],
  ac_cv_decl_h_errno,
[AC_TRY_COMPILE([#include <netdb.h>], [int err = h_errno;],
  ac_cv_decl_h_errno=yes, ac_cv_decl_h_errno=no)])
if test $ac_cv_decl_h_errno = yes; then
  AC_DEFINE(H_ERRNO_DECLARED,[1],
	[define if h_errno is declared (in some way) in a system header file])
fi


dnl ----------------------------------------------------------------------
dnl Checks for header files.
dnl ----------------------------------------------------------------------

dnl We sometimes need EMU_THR_DEFS in order to find certain headers.
saved_cppflags=$CPPFLAGS
CPPFLAGS="$CPPFLAGS $EMU_THR_DEFS"

AC_HEADER_DIRENT
AC_HEADER_STDC
AC_HEADER_SYS_WAIT
AC_HEADER_TIME

dnl Interactive UX needs <net/errno.h> for socket related error codes.
dnl Some Linuxes needs <sys/socketio.h> instead of <sys/sockio.h>
dnl
AC_CHECK_HEADERS(fcntl.h limits.h unistd.h syslog.h dlfcn.h ieeefp.h \
                 sys/types.h sys/stropts.h sys/sysctl.h \
                 sys/ioctl.h sys/time.h sys/uio.h \
                 sys/socket.h sys/sockio.h sys/socketio.h \
                 net/errno.h malloc.h arpa/nameser.h libdlpi.h \
		 pty.h util.h libutil.h utmp.h langinfo.h poll.h sdkddkver.h)

AC_CHECK_MEMBERS([struct ifreq.ifr_hwaddr], [], [],
	[#ifdef __WIN32__
	 #else
	 #ifdef VXWORKS
	 #else
	 #include <net/if.h>
	 #endif
	 #endif
	])

AC_CHECK_MEMBERS([struct ifreq.ifr_enaddr], [], [],
	[#ifdef __WIN32__
	 #else
	 #ifdef VXWORKS
	 #else
	 #include <net/if.h>
	 #endif
	 #endif
	])

dnl ----------------------------------------------------------------------
dnl  Check the availability of systemd
dnl ----------------------------------------------------------------------
if test x"$enable_systemd" != x"no"; then

systemd_daemon_save_LIBS=$LIBS
LIBS=
AC_SEARCH_LIBS(sd_listen_fds,[systemd systemd-daemon],
  [have_sd_listen_fds=yes],[have_sd_listen_fds=no],$systemd_daemon_save_LIBS)
AC_SEARCH_LIBS(sd_notify,[systemd systemd-daemon],
  [have_sd_notify=yes],[have_sd_notify=no],$systemd_daemon_save_LIBS)
AC_CHECK_HEADERS(systemd/sd-daemon.h,
  [have_systemd_sd_daemon_h=yes],[have_systemd_sd_daemon_h=no])

if test x"$have_sd_listen_fds" = x"yes" && \
   test x"$have_sd_notify" = x"yes" && \
   test x"$have_systemd_sd_daemon_h" = x"yes"; then
  AC_DEFINE([HAVE_SYSTEMD_DAEMON],[1],[Define if you have systemd daemon])
  SYSTEMD_DAEMON_LIBS=$LIBS
elif test x"$enable_systemd" = x"yes"; then
  AC_MSG_FAILURE([--enable-systemd was given, but test for systemd failed])
fi
LIBS=$systemd_daemon_save_LIBS
fi
AC_SUBST(SYSTEMD_DAEMON_LIBS)


dnl ----------------------------------------------------------------------
dnl Check the availability for libdlpi
dnl ----------------------------------------------------------------------
AC_CHECK_LIB(dlpi, dlpi_open)
if test x"$ac_cv_lib_dlpi_dlpi_open" = x"no"; then
   unset -v ac_cv_lib_dlpi_dlpi_open
   dnl Try again now with -L/lib (or ditto 64) as argument to linker since
   dnl gcc makes /usr/ccs/bin/ld ignore the crle configured linker default paths
   dnl typically causing dlpi not being found on Solaris et.al
   save_ldflags="$LDFLAGS"
   try_dlpi_lib=/lib
   if test x"$ac_cv_sizeof_void_p" = x"8"; then
      if test -d /lib64; then
	 try_dlpi_lib=/lib64
      elif test -d /lib/64; then
	 try_dlpi_lib=/lib/64
      fi
   fi
   if test ! -f "$try_dlpi_lib/libdlpi.so" && \
      test -f "$try_dlpi_lib/libdlpi.so.1"
   then
      dnl It looks like there is a missing symlink
      dnl - let's be helpful and notify the user
      dnl NOTE this help is far from perfect e.g if there would be no
      dnl *.so.1 but a *.so.1.123 or *.so.2 this will be no help
      AC_MSG_ERROR(
	[Your OS installation is missing a symbolic link.
	Maybe it lacks some development package(s)...
	It can anyhow be fixed with the following command:
	# ln -s libdlpi.so.1 $try_dlpi_lib/libdlpi.so
	])
   fi
   LDFLAGS="-L$try_dlpi_lib -R$try_dlpi_lib $LDFLAGS"
   unset -v try_dlpi_lib
   AC_MSG_NOTICE([Extending the search to include /lib])
   AC_CHECK_LIB(dlpi, dlpi_open)
   if test x"$ac_cv_lib_dlpi_dlpi_open" = x"no"; then
      LDFLAGS="$save_ldflags"
   fi
   unset -v save_ldflags
fi

AC_CHECK_HEADER(sys/resource.h,
	[AC_DEFINE(HAVE_SYS_RESOURCE_H, 1,
		[Define to 1 if you have the <sys/resource.h> header file])
	 AC_CHECK_DECLS([getrlimit, setrlimit, RLIMIT_STACK],
		[],[],
		[#include <sys/resource.h>])],
	[],[])

AC_CHECK_FUNCS([getrusage])

dnl Check if we have kernel poll support
have_kernel_poll=no
AC_CHECK_HEADER(sys/event.h, have_kernel_poll=kqueue)
AC_CHECK_HEADER(sys/epoll.h, have_kernel_poll=epoll)
AC_CHECK_HEADER(sys/devpoll.h, have_kernel_poll=/dev/poll)

dnl Check if we have timerfds to be used for high accuracy
dnl epoll_wait timeouts
AC_CHECK_HEADERS([sys/timerfd.h])

dnl Check for kernel SCTP support
AC_SUBST(LIBSCTP)
if test "x$enable_sctp" != "xno" ; then
    AC_CHECK_HEADER(netinet/sctp.h,
        [LIBSCTP=libsctp.so.1
	 AC_DEFINE(HAVE_SCTP_H, [1],
            [Define to 1 if you have the <netinet/sctp.h> header file])],
	[],
	[#if HAVE_SYS_SOCKET_H
	 #include <sys/socket.h>
	 #endif
	])
fi

if test x"$ac_cv_header_netinet_sctp_h" = x"yes"; then
    AS_IF([test "x$enable_sctp" = "xlib"],
        AC_CHECK_LIB(sctp, sctp_bindx))
    AC_CHECK_FUNCS([sctp_bindx sctp_peeloff sctp_getladdrs sctp_freeladdrs sctp_getpaddrs sctp_freepaddrs])
    AC_CHECK_DECLS([SCTP_UNORDERED, SCTP_ADDR_OVER, SCTP_ABORT,
                    SCTP_EOF, SCTP_SENDALL, SCTP_ADDR_CONFIRMED,
		    SCTP_DELAYED_ACK_TIME,
		    SCTP_EMPTY, SCTP_UNCONFIRMED,
		    SCTP_CLOSED, SCTPS_IDLE,
		    SCTP_BOUND, SCTPS_BOUND,
		    SCTP_LISTEN, SCTPS_LISTEN,
		    SCTP_COOKIE_WAIT, SCTPS_COOKIE_WAIT,
		    SCTP_COOKIE_ECHOED, SCTPS_COOKIE_ECHOED,
		    SCTP_ESTABLISHED, SCTPS_ESTABLISHED,
		    SCTP_SHUTDOWN_PENDING, SCTPS_SHUTDOWN_PENDING,
		    SCTP_SHUTDOWN_SENT, SCTPS_SHUTDOWN_SENT,
		    SCTP_SHUTDOWN_RECEIVED, SCTPS_SHUTDOWN_RECEIVED,
		    SCTP_SHUTDOWN_ACK_SENT, SCTPS_SHUTDOWN_ACK_SENT], [], [],
        [#if HAVE_SYS_SOCKET_H
         #include <sys/socket.h>
         #endif
         #include <netinet/sctp.h>
        ])
    AC_CHECK_MEMBERS([struct sctp_paddrparams.spp_pathmtu,
                      struct sctp_paddrparams.spp_sackdelay,
                      struct sctp_paddrparams.spp_flags,
                      struct sctp_remote_error.sre_data,
                      struct sctp_send_failed.ssf_data], [], [],
        [#if HAVE_SYS_SOCKET_H
         #include <sys/socket.h>
         #endif
         #include <netinet/sctp.h>
        ])
fi

dnl Check for setns
AC_CHECK_HEADERS(sched.h setns.h)
AC_CHECK_FUNCS([setns])

HAVE_VALGRIND=no
AC_CHECK_HEADER(valgrind/valgrind.h, HAVE_VALGRIND=yes)
AC_SUBST(HAVE_VALGRIND)

LM_DECL_SO_BSDCOMPAT
LM_DECL_INADDR_LOOPBACK
LM_DECL_SYS_ERRLIST

AC_CACHE_CHECK([if windows.h includes winsock2.h],
		erts_cv_windows_h_includes_winsock2_h,
		AC_TRY_COMPILE([#include <windows.h>
				],
			       [#ifndef _WINSOCK2API_
				#error winsock2.h not included
				#endif
				int i = 1;
				],
			       erts_cv_windows_h_includes_winsock2_h=yes,
			       erts_cv_windows_h_includes_winsock2_h=no))
if test $erts_cv_windows_h_includes_winsock2_h = yes; then
	AC_DEFINE(WINDOWS_H_INCLUDES_WINSOCK2_H, 1, \
[Define if windows.h includes winsock2.h])
fi

dnl restore CPPFLAGS
CPPFLAGS=$saved_cppflags

dnl ----------------------------------------------------------------------
dnl Checks for typedefs, structures, and compiler characteristics.
dnl ----------------------------------------------------------------------

AC_C_CONST
AC_TYPE_SIGNAL
AC_TYPE_OFF_T
AC_TYPE_PID_T
AC_TYPE_SIZE_T

AC_STRUCT_TM
LM_STRUCT_SOCKADDR_SA_LEN
LM_STRUCT_EXCEPTION

AC_CHECK_SIZEOF(char, 1)
AC_CHECK_SIZEOF(short)
AC_CHECK_SIZEOF(int)
AC_CHECK_SIZEOF(long)
AC_CHECK_SIZEOF(void *)
AC_CHECK_SIZEOF(long long)
AC_CHECK_SIZEOF(size_t)
AC_CHECK_SIZEOF(off_t)
AC_CHECK_SIZEOF(time_t)

BITS64=

if test $ac_cv_sizeof_void_p = 8; then
  BITS64=yes
fi
AC_SUBST(BITS64)

AC_MSG_CHECKING([for C compiler 'restrict' support])
restrict_keyword=""
for x in restrict __restrict; do
    AC_TRY_COMPILE([int * $x foo(int * $x arg);
		    int * $x foo(int * $x arg)
		        { int * $x var=arg; return var;}
		   ],[],
		   [restrict_keyword=$x],[])
    if test "x$restrict_keyword" != "x"; then
	break
    fi
done
AC_DEFINE_UNQUOTED(ERTS_RESTRICT,[$restrict_keyword],[Type qualifier restrict])
if test "x$restrict_keyword" != "x"; then
   AC_MSG_RESULT(yes)
else
   AC_MSG_RESULT(no)
fi

if test "x$ac_compiler_gnu" = "xyes"; then
AC_MSG_CHECKING([if we should add -fno-tree-copyrename to CFLAGS for computed gotos to work properly])
AC_TRY_COMPILE([],[
		#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)
			;
			#else
			#error old and ok
			#endif
			],
			no_tree_copyrename=yes,
			no_tree_copyrename=no)

if test "x$no_tree_copyrename" = "xyes"; then
	CFLAGS="$CFLAGS -fno-tree-copyrename"
	AC_MSG_RESULT(yes, adjusting CFLAGS)
else
	AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING([for broken gcc-4.3.0 compiler])
AC_TRY_RUN([
/* pr36339.c */
extern void abort (void);

typedef unsigned long my_uintptr_t;

int check_a(my_uintptr_t tagged_ptr);

int __attribute__((noinline)) try_a(my_uintptr_t x)
{
  my_uintptr_t heap[2];
  my_uintptr_t *hp = heap;

  hp[0] = x;
  hp[1] = 0;
  return check_a((my_uintptr_t)(void*)((char*)hp + 1));
}

int __attribute__((noinline)) check_a(my_uintptr_t tagged_ptr)
{
  my_uintptr_t *hp = (my_uintptr_t*)(void*)((char*)tagged_ptr - 1);

  if (hp[0] == 42 && hp[1] == 0)
    return 0;
  return -1;
}

int main(void)
{
  if (try_a(42) < 0)
    abort ();
  return 0;
}
], gcc_4_3_0_bug=no, gcc_4_3_0_bug=yes, gcc_4_3_0_bug=cross)

case $gcc_4_3_0_bug in
	yes|no)
		gcc_4_3_0_bug_result=$gcc_4_3_0_bug;;
	cross)
		gcc_dumped_vsn=`$CC -dumpversion 2>/dev/null`
		case gcc-$gcc_dumped_vsn in
			gcc-4.3.0) gcc_4_3_0_bug=yes;;
			*) gcc_4_3_0_bug=no;;
		esac
		gcc_4_3_0_bug_result="$gcc_4_3_0_bug; could not run test since cross compiling, checked version number ($gcc_dumped_vsn) instead";;
esac

AC_MSG_RESULT([$gcc_4_3_0_bug_result])
if test $gcc_4_3_0_bug = yes; then
	AC_MSG_ERROR([This gcc miscompiles the Erlang runtime system; please use a different version])	
fi

fi

case X$erl_xcomp_bigendian in
    X) ;;
    Xyes|Xno) ac_cv_c_bigendian=$erl_xcomp_bigendian;;
    *) AC_MSG_ERROR([Bad erl_xcomp_bigendian value: $erl_xcomp_bigendian]);;
esac

AC_C_BIGENDIAN(
	[
	 AC_DEFINE([WORDS_BIGENDIAN], [1], [Define if big-endian])
	 AC_DEFINE([ERTS_ENDIANNESS], [1], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown])
	],
	[
	 AC_DEFINE([ERTS_ENDIANNESS], [-1], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown])
	],
	[
	  case "$erl_xcomp_bigendian" in
	    yes)
	     AC_DEFINE([ERTS_ENDIANNESS], [1], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown]);;
	    no)
	     AC_DEFINE([ERTS_ENDIANNESS], [-1], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown]);;
	    *)
	     AC_DEFINE([ERTS_ENDIANNESS], [0], [Define > 0 if big-endian < 0 if little-endian, or 0 if unknown]);;
	  esac
	])	

AC_C_DOUBLE_MIDDLE_ENDIAN

dnl fdatasync syscall (Unix only)
AC_CHECK_FUNCS([fdatasync])

dnl Find which C libraries are required to use fdatasync
dnl TODO: Remove check once SunOS >= 5.11 is required by erts.
dnl       fdatasync requires linking against -lrt on SunOS <= 5.10.
dnl       OpenSolaris 2009.06 is SunOS 5.11 and does not require -lrt.
AC_SEARCH_LIBS(fdatasync, [rt])


dnl sendfile syscall
case $host_os in
    linux*|freebsd*|dragonfly*|darwin*)
		AC_CHECK_FUNCS([sendfile])
		;;
    solaris*)
		AC_SEARCH_LIBS(sendfilev, sendfile,
			AC_DEFINE([HAVE_SENDFILEV],[1],
		           [Define to 1 if you have the `sendfilev' function.]))
		;;
    win32)
		LIBS="$LIBS -lmswsock"
		;;
    *)
		;;
esac

dnl ----------------------------------------------------------------------
dnl Checks for library functions.
dnl ----------------------------------------------------------------------

dnl We may need the thread library and thread flags in order to find right stuff
saved_cppflags=$CPPFLAGS
CPPFLAGS="$CPPFLAGS $EMU_THR_DEFS"
saved_libs=$LIBS
LIBS="$LIBS $EMU_THR_X_LIBS"

dnl Check if we have these, in which case we'll try to build
dnl inet_gethost with ipv6 support.
AC_CHECK_HEADERS(windows.h)
AC_CHECK_HEADERS(winsock2.h)
AC_CHECK_HEADERS(ws2tcpip.h,[],[],[
#ifdef HAVE_WINSOCK2_H
#include <winsock2.h>
#endif
#ifdef HAVE_WINDOWS_H
#include <windows.h>
#endif
])
dnl AC_CHECK_FUNC(getaddrinfo, have_getaddrinfo=yes, have_getaddrinfo=no)
AC_MSG_CHECKING(for getaddrinfo)
AC_TRY_LINK([
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_WINSOCK2_H
#include <winsock2.h>
#endif
#ifdef HAVE_WINDOWS_H
#include <windows.h>
#endif
#ifdef HAVE_WS2TCPIP_H
#include <ws2tcpip.h>
#endif
#ifndef __WIN32__
#include <sys/socket.h>
#include <netdb.h>
#endif
], 
[
getaddrinfo("","",NULL,NULL);
],have_getaddrinfo=yes, have_getaddrinfo=no)
if test $have_getaddrinfo = yes; then
        AC_MSG_RESULT([yes])
        AC_MSG_CHECKING([whether getaddrinfo accepts enough flags])
        AC_TRY_LINK([
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_WINSOCK2_H
#include <winsock2.h>
#endif
#ifdef HAVE_WINDOWS_H
#include <windows.h>
#endif
#ifdef HAVE_WS2TCPIP_H
#include <ws2tcpip.h>
#endif
#ifndef __WIN32__
#include <sys/socket.h>
#include <netdb.h>
#endif
],
[
    struct addrinfo hints, *ai;
    memset(&hints, 0, sizeof(hints));
    hints.ai_flags = AI_CANONNAME;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_family = AF_INET6;
    if (getaddrinfo("::", NULL, &hints, &ai) == 0) {
	freeaddrinfo(ai);
	exit(0);
    } else {
	exit(1);
    }
],, have_getaddrinfo=no)
	AC_MSG_RESULT($have_getaddrinfo)
	case $have_getaddrinfo in
	    yes)
		AC_DEFINE(HAVE_GETADDRINFO, [1], 
		          [Define to 1 if you have a good `getaddrinfo' function.]);;
	    *) ;;
	esac
else
    AC_MSG_RESULT([no])
fi
AC_MSG_CHECKING(for getnameinfo)
AC_TRY_LINK([
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_WINSOCK2_H
#include <winsock2.h>
#endif
#ifdef HAVE_WINDOWS_H
#include <windows.h>
#endif
#ifdef HAVE_WS2TCPIP_H
#include <ws2tcpip.h>
#endif
#ifndef __WIN32__
#include <sys/socket.h>
#include <netdb.h>
#endif
], 
[
getnameinfo(NULL,0,NULL,0,NULL,0,0);
],have_getnameinfo=yes, have_getnameinfo=no)
if test $have_getnameinfo = yes; then
        AC_MSG_RESULT([yes])
	AC_DEFINE(HAVE_GETNAMEINFO, [1], 
		  [Define to 1 if you have a good `getnameinfo' function.])
else
	AC_MSG_RESULT([no])	  
fi


AC_CHECK_FUNCS([getipnodebyname getipnodebyaddr gethostbyname2])

AC_CHECK_FUNCS([ieee_handler fpsetmask finite isnan isinf res_gethostbyname dlopen \
		pread pwrite memmove strerror strerror_r strncasecmp \
		gethrtime localtime_r gmtime_r inet_pton mprotect \
		mmap mremap memcpy mallopt sbrk _sbrk __sbrk brk _brk __brk \
		flockfile fstat strlcpy strlcat setsid posix2time time2posix \
		setlocale nl_langinfo poll mlockall ppoll])

AC_MSG_CHECKING([for isfinite])
AC_TRY_LINK([#include <math.h>],
            [isfinite(0);], have_isfinite=yes, have_isfinite=no),

if test $have_isfinite = yes; then
    AC_DEFINE(HAVE_ISFINITE,[1],
              [Define to 1 if you have the `isfinite' function.])
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

case X$erl_xcomp_posix_memalign in
     Xno) ;;
     Xyes) have_posix_memalign=yes ;;
     *)
	AC_CHECK_FUNC(
		[posix_memalign],
                [if test "$cross_compiling" != yes; then
AC_TRY_RUN([
#include <stdlib.h>
int main(void) {
    void *ptr = NULL;
    int error;
    size_t alignment = 0x40000, size = 0x20028;
    if ((error = posix_memalign(&ptr, alignment, size)) != 0 || ptr == NULL)
      return error;
    return 0;
}
],have_posix_memalign=yes
)
		 else
			have_posix_memalign=yes
		 fi]);;
esac

if test "$have_posix_memalign" = "yes"; then
   AC_DEFINE(HAVE_POSIX_MEMALIGN,[1],
	     [Define to 1 if you have the `posix_memalign' function.])
fi


dnl writev on OS X snow leopard is broken for files > 4GB
case $host_os in
        darwin10.8.0)
	    AC_MSG_CHECKING([for writev])
	    AC_MSG_RESULT(no, not stable on OS X Snow Leopard) ;;
        *)
	    AC_CHECK_FUNCS([writev]) ;;
esac

AC_CHECK_DECLS([posix2time, time2posix],,,[#include <time.h>])

disable_vfork=false
if test "x$EMU_THR_LIB_NAME" != "x"; then
	AC_MSG_CHECKING([if vfork is known to hang multithreaded applications])
	case $host_os in
		osf*)
			AC_MSG_RESULT(yes)
			disable_vfork=true;;
		*)
			AC_MSG_RESULT(no);;
	esac
fi

if test $disable_vfork = false; then
	AC_FUNC_VFORK
	if test $ac_cv_func_vfork_works = no; then
		disable_vfork=true
	fi
fi

if test $disable_vfork = true; then
	AC_DEFINE(DISABLE_VFORK, 1, [Define if you want to disable vfork.])
fi

AC_FUNC_VPRINTF

dnl The AC_DEFINEs are necessary for autoheader to work. :-(
dnl for gzio
LM_CHECK_FUNC_DECL(fread, [extern int fread();],,
                   AC_DEFINE(HAVE_CONFLICTING_FREAD_DECLARATION,[1],[Define if you have a decl of fread that conflicts with int fread]))

dnl Checking with TRY_LINK since putc_unlocked might be (probably is) a macro
AC_CACHE_CHECK([for putc_unlocked],
	erts_cv_putc_unlocked,
	AC_TRY_LINK([#include <stdio.h>],
		[int res = putc_unlocked('x',stdout);],
		erts_cv_putc_unlocked=yes,
             	erts_cv_putc_unlocked=no))
if test $erts_cv_putc_unlocked = yes; then
	AC_DEFINE(HAVE_PUTC_UNLOCKED, 1, [Define if you have putc_unlocked])
fi

dnl Checking with TRY_LINK since fwrite_unlocked might be a macro
AC_CACHE_CHECK([for fwrite_unlocked],
	erts_cv_fwrite_unlocked,
	AC_TRY_LINK([#include <stdio.h>],
		[size_t res = fwrite_unlocked(NULL,sizeof(char),0,stdout);],
		erts_cv_fwrite_unlocked=yes,
             	erts_cv_fwrite_unlocked=no))
if test $erts_cv_fwrite_unlocked = yes; then
	AC_DEFINE(HAVE_FWRITE_UNLOCKED, 1, [Define if you have fwrite_unlocked])
fi

dnl Need by run_erl.
AC_CHECK_FUNCS([openpty])

AC_CHECK_HEADERS(net/if_dl.h ifaddrs.h netpacket/packet.h sys/un.h)
AC_CHECK_FUNCS([getifaddrs])

dnl Checks for variables in6addr_any and in6addr_loopback,
dnl
dnl They normally declared by netinet/in.h, according to POSIX,
dnl but not on Windows 7 (Windows SDK 7.1).  I would have liked
dnl to just write AC_CHECK_DECL([in6addr_any], ...) but if doing so,
dnl the configure check fails erroneously on Linux with the error
dnl "cannot convert to a pointer type", on a line looking like
dnl "char *p = (char *) in6addr_any;", so work around that
dnl with some more code. 
AC_CACHE_CHECK(
    [whether in6addr_any is declared],
    [erts_cv_have_in6addr_any],
    [AC_LINK_IFELSE(
	[AC_LANG_PROGRAM(
	    [[
		#include <sys/types.h>
		#include <sys/socket.h>
		#include <netinet/in.h>
	    ]],
	    [[printf("%d", in6addr_any.s6_addr[16]);]]
	)],
	[erts_cv_have_in6addr_any=yes],
	[erts_cv_have_in6addr_any=no]
    )]
)

case "$erts_cv_have_in6addr_any" in
 yes)
   AC_DEFINE([HAVE_IN6ADDR_ANY], [1],
             [Define to 1 if you have the variable in6addr_any declared.])
esac

AC_CACHE_CHECK(
    [whether in6addr_loopback is declared],
    [erts_cv_have_in6addr_loopback],
    [AC_LINK_IFELSE(
	[AC_LANG_PROGRAM(
	    [[
		#include <sys/types.h>
		#include <sys/socket.h>
		#include <netinet/in.h>
	    ]],
	    [[printf("%d", in6addr_loopback.s6_addr[16]);]]
	)],
	[erts_cv_have_in6addr_loopback=yes],
	[erts_cv_have_in6addr_loopback=no]
    )]
)

case "$erts_cv_have_in6addr_loopback" in
 yes)
   AC_DEFINE([HAVE_IN6ADDR_LOOPBACK], [1],
             [Define to 1 if you have the variable in6addr_loopback declared.])
esac

AC_CHECK_DECLS([IN6ADDR_ANY_INIT, IN6ADDR_LOOPBACK_INIT, IPV6_V6ONLY], [], [],
	       [
		#include <sys/types.h>
		#include <sys/socket.h>
		#include <netinet/in.h>
	       ])

dnl ----------------------------------------------------------------------
dnl Checks for features/quirks in the system that affects Erlang.
dnl ----------------------------------------------------------------------

AC_MSG_CHECKING([for sched_getaffinity/sched_setaffinity])
AC_TRY_LINK([#include <sched.h>],
[
#ifndef CPU_SETSIZE
#error no CPU_SETSIZE
#endif
	int res;
	cpu_set_t cpuset;
	CPU_ZERO(&cpuset);
	CPU_SET(1, &cpuset);
	res = sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);
	res = sched_getaffinity(0, sizeof(cpu_set_t), &cpuset);
	res = CPU_ISSET(1, &cpuset);
	CPU_CLR(1, &cpuset);
],
		sched_xetaffinity=yes,
		sched_xetaffinity=no)
AC_MSG_RESULT([$sched_xetaffinity])
if test $sched_xetaffinity = yes; then
	AC_DEFINE(HAVE_SCHED_xETAFFINITY, 1, [Define if you have sched_getaffinity/sched_setaffinity])
fi


AC_MSG_CHECKING([for pset functionality])
AC_TRY_LINK([#include <sys/pset.h>],
[
	int res;
	psetid_t id = PS_MYID;
	int type = PS_PRIVATE;
	uint_t numcpus = 1024;
	processorid_t cpulist[1024];

	res = pset_info(id, &type, &numcpus, &cpulist[0]);
],
		pset_functionality=yes,
		pset_functionality=no)
AC_MSG_RESULT([$pset_functionality])
if test $pset_functionality = yes; then
	AC_DEFINE(HAVE_PSET, 1, [Define if you have pset functionality])
fi

AC_MSG_CHECKING([for processor_bind functionality])
AC_TRY_LINK([
#include <sys/types.h>
#include <sys/processor.h>
#include <sys/procset.h>
],
[
	int res = processor_bind(P_LWPID, P_MYID, PBIND_NONE, NULL);
],
		processor_bind_functionality=yes,
		processor_bind_functionality=no)
AC_MSG_RESULT([$processor_bind_functionality])
if test $processor_bind_functionality = yes; then
	AC_DEFINE(HAVE_PROCESSOR_BIND, 1, [Define if you have processor_bind functionality])
fi

AC_MSG_CHECKING([for cpuset_getaffinity/cpuset_setaffinity])
AC_TRY_LINK([
#include <sys/param.h>
#include <sys/cpuset.h>
],
[
	int res;
	cpuset_t cpuset;
	CPU_ZERO(&cpuset);
	CPU_SET(1, &cpuset);
	res = cpuset_setaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(cpuset_t), &cpuset);
	res = cpuset_getaffinity(CPU_LEVEL_WHICH, CPU_WHICH_PID, -1, sizeof(cpuset_t), &cpuset);
	res = CPU_ISSET(1, &cpuset);
	CPU_CLR(1, &cpuset);
],
		cpuset_xetaffinity=yes,
		cpuset_xetaffinity=no)
AC_MSG_RESULT([$cpuset_xetaffinity])
if test $cpuset_xetaffinity = yes; then
	AC_DEFINE(HAVE_CPUSET_xETAFFINITY, 1, [Define if you have cpuset_getaffinity/cpuset_setaffinity])
fi

AC_CACHE_CHECK([for 'end' symbol],
		erts_cv_have_end_symbol,
		[AC_TRY_LINK([],
			[extern char end; {char *x = &end; *x= 0;}],
			erts_cv_have_end_symbol=yes,
			erts_cv_have_end_symbol=no)])
if test $erts_cv_have_end_symbol = yes; then
	AC_DEFINE(HAVE_END_SYMBOL, 1, [Define if you have the 'end' symbol])
fi

AC_CACHE_CHECK([for '_end' symbol],
		erts_cv_have__end_symbol,
		[AC_TRY_LINK([],
			[extern char _end; {char *x = &_end; *x= 0;}],
			erts_cv_have__end_symbol=yes,
			erts_cv_have__end_symbol=no)])
if test $erts_cv_have__end_symbol = yes; then
	AC_DEFINE(HAVE__END_SYMBOL, 1, [Define if you have the '_end' symbol])
fi

AC_CACHE_CHECK([if __after_morecore_hook can track malloc()s core memory use],
		erts_cv___after_morecore_hook_can_track_malloc,
		[AC_TRY_RUN([
#include <stdlib.h>
#ifdef HAVE_MALLOC_H
#  include <malloc.h>
#endif
#if defined(HAVE_END_SYMBOL)
extern char end;
#elif defined(HAVE__END_SYMBOL)
extern char _end;
#endif

#ifdef ETHR_PTHREADS
#  ifdef ETHR_HAVE_PTHREAD_H
#    include <pthread.h>
#  else
#    ifdef ETHR_HAVE_MIT_PTHREAD_H
#      include <pthread/mit/pthread.h>
#    endif
#  endif
#  define N_THR 5
#else
#  define N_THR 1
#endif

static char *heap_start = NULL;
static char *heap_end = NULL;

void update_heap_size(void)
{
    heap_end = (char *) sbrk(0);
}

void init_hook(void)
{
#if defined(HAVE_END_SYMBOL)
    heap_start = &end;
#elif defined(HAVE__END_SYMBOL)
    heap_start = &_end;
#else
    heap_start = sbrk(0);
#endif
    __after_morecore_hook = update_heap_size;
}

void (*__malloc_initialize_hook) (void) = init_hook;

static int
check_malloc(int size)
{
    char *p = (char *) malloc(size);
    if (!heap_start || !heap_end) return 0;
    if (!p) return 0;
    if (p < heap_start || heap_end <= p) return 0;
    if (p + size < heap_start || heap_end < p + size) return 0;
    return 1;
}

#ifdef ETHR_PTHREADS
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
#endif

static void *
do_tests(void *vresp)
{
    int i, ok = 0;
#ifdef ETHR_PTHREADS
    if (pthread_mutex_lock(&mutex) != 0)
	return NULL;
#endif

    for (i = 0; i < 10; i++)
	if (!check_malloc(1000))
	    goto failed;
    for (i = 0; i < 100; i++)
	if (!check_malloc(1))
	    goto failed;
    if (!check_malloc(1024*1024+1))
	goto failed;
    if (!check_malloc(10*1024*1024+1))
	goto failed;
    ok = 1;

 failed:
#ifdef ETHR_PTHREADS
    if (pthread_mutex_unlock(&mutex) != 0)
	return NULL;
#endif
    if (ok)
	*((int *) vresp) = 0;
    return NULL;
}


int main(void)
{
    int res[N_THR], i;
#ifdef ETHR_PTHREADS
    pthread_t tid[N_THR];
#endif

#if defined(HAVE_MALLOPT) && defined(M_MMAP_MAX)
    (void) mallopt(M_MMAP_MAX, 0);
#endif

    for (i = 0; i < N_THR; i++)
	res[i] = 1;
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_create(&tid[i], NULL, do_tests, &res[i]) != 0)
	    return 1;
#endif
    (void) do_tests(&res[0]);
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_join(tid[i], NULL) != 0)
	    return 1;
#endif
    for (i = 0; i < N_THR; i++)
	if (res[i])
	    return 1;
    return 0;
}
	],
	erts_cv___after_morecore_hook_can_track_malloc=yes,
	erts_cv___after_morecore_hook_can_track_malloc=no,
	[
	case X$erl_xcomp_after_morecore_hook in
	    X) erts_cv___after_morecore_hook_can_track_malloc=cross;;
	    Xyes|Xno) erts_cv___after_morecore_hook_can_track_malloc=$erl_xcomp_after_morecore_hook;;
	    *) AC_MSG_ERROR([Bad erl_xcomp_after_morecore_hook value: $erl_xcomp_after_morecore_hook]);;
	esac
	]
	)])

case $erts_cv___after_morecore_hook_can_track_malloc in
	yes) AC_DEFINE(ERTS___AFTER_MORECORE_HOOK_CAN_TRACK_MALLOC, 1, \
[Define if __after_morecore_hook can track malloc()s core memory use.]);;
	cross) AC_MSG_WARN([result no guessed because of cross compilation]);;
	*) ;;
esac

if test "x$ac_cv_func_sbrk" = "xyes"; then
    AC_CACHE_CHECK([types of sbrk()s return value and argument],
		    erts_cv_sbrk_ret_arg_types,
		    [

	erts_cv_sbrk_ret_arg_types=unknown
	ret_types="void *,char *"
	arg_types="intptr_t,ptrdiff_t,int,long"
	save_ifs="$IFS"; IFS=","
	for rtype in $ret_types; do
	    for atype in $arg_types; do
		IFS=$save_ifs
		AC_TRY_LINK([#include <sys/types.h>
				#include <unistd.h>],
				[$rtype sbrk($atype incr);],
				[erts_cv_sbrk_ret_arg_types="$rtype,$atype"])
		IFS=","
		if test "$erts_cv_sbrk_ret_arg_types" != "unknown"; then
		    break 2
		fi
	    done
	done
	IFS=$save_ifs])
    
    if test "$erts_cv_sbrk_ret_arg_types" != "unknown"; then
	save_ifs="$IFS"; IFS=","
	read ret_type arg_type <<EOF
$erts_cv_sbrk_ret_arg_types
EOF
	IFS=$save_ifs
	AC_DEFINE_UNQUOTED(SBRK_RET_TYPE, $ret_type, \
[Define the sbrk() return type.])
	AC_DEFINE_UNQUOTED(SBRK_ARG_TYPE, $arg_type, \
[Define the sbrk() argument type.])
    fi
fi

if test $ac_cv_func_brk = yes; then
    AC_CACHE_CHECK([types of brk()s return value and argument],
		    erts_cv_brk_ret_arg_types,
		    [

	erts_cv_brk_ret_arg_types=unknown
	ret_types="int,long,char *,void *"
	arg_types="void *,const void *,char *,const char *"
	save_ifs="$IFS"; IFS=","
	for rtype in $ret_types; do
	    for atype in $arg_types; do
		IFS=$save_ifs
		AC_TRY_LINK([#include <sys/types.h>
				#include <unistd.h>],
				[$rtype brk($atype endds);],
				[erts_cv_brk_ret_arg_types="$rtype,$atype"])
		IFS=","
		if test "$erts_cv_brk_ret_arg_types" != "unknown"; then
		    break 2
		fi
	    done
	done
	IFS=$save_ifs])
    
    if test "$erts_cv_brk_ret_arg_types" != "unknown"; then
	save_ifs="$IFS"; IFS=","
	read ret_type arg_type <<EOF
$erts_cv_brk_ret_arg_types
EOF
	IFS=$save_ifs
	AC_DEFINE_UNQUOTED(BRK_RET_TYPE, $ret_type, \
[Define the brk() return type.])
	AC_DEFINE_UNQUOTED(BRK_ARG_TYPE, $arg_type, \
[Define the brk() argument type.])
    fi

fi

if test $ac_cv_func_sbrk = yes; then

    AC_CACHE_CHECK([if sbrk()/brk() wrappers can track malloc()s core memory use],
		    erts_cv_brk_wrappers_can_track_malloc,
		    [AC_TRY_RUN([
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#ifdef HAVE_DLFCN_H
#  include <dlfcn.h>
#endif

/*
 * Our implementation requires that we have sbrk(), and 'end' or '_end'.
 */

#if !defined(HAVE_SBRK)
#  error no sbrk()
#endif
#if defined(HAVE_END_SYMBOL)
extern char end;
#elif defined(HAVE__END_SYMBOL)
extern char _end;
#else
#  error no 'end' nor '_end'
#endif

#ifdef ETHR_PTHREADS
#  ifdef ETHR_HAVE_PTHREAD_H
#    include <pthread.h>
#  else
#    ifdef ETHR_HAVE_MIT_PTHREAD_H
#      include <pthread/mit/pthread.h>
#    endif
#  endif
#  define N_THR 5
#else
#  define N_THR 1
#endif

#define SBRK_IMPL(RET_TYPE, SBRK, ARG_TYPE)				\
RET_TYPE SBRK (ARG_TYPE);						\
static RET_TYPE (*real_ ## SBRK)(ARG_TYPE) = NULL;			\
RET_TYPE								\
SBRK (ARG_TYPE arg)							\
{									\
    RET_TYPE res;							\
    if (!real_ ## SBRK) real_ ## SBRK = dlsym(RTLD_NEXT, #SBRK);	\
    res = (*real_ ## SBRK)(arg);					\
    if (res != (RET_TYPE) -1) heap_end = (char *) (*real_ ## SBRK)(0);	\
    return res;								\
}

#define BRK_IMPL(RET_TYPE, BRK, ARG_TYPE)				\
RET_TYPE BRK (ARG_TYPE);						\
static RET_TYPE (*real_ ## BRK)(ARG_TYPE) = NULL;			\
RET_TYPE								\
BRK (ARG_TYPE arg)							\
{									\
    RET_TYPE res;							\
    if (!real_ ## BRK) real_ ## BRK = dlsym(RTLD_NEXT, #BRK);		\
    res = (*real_ ## BRK)(arg);						\
    if (res != (RET_TYPE) -1) heap_end = (char *) arg;			\
    return res;								\
}

static char *heap_start = NULL;
static char *heap_end = NULL;

SBRK_IMPL(SBRK_RET_TYPE, sbrk, SBRK_ARG_TYPE)
#ifdef HAVE_BRK
   BRK_IMPL(BRK_RET_TYPE, brk, BRK_ARG_TYPE)
#endif

#ifdef HAVE__SBRK
   SBRK_IMPL(SBRK_RET_TYPE, _sbrk, SBRK_ARG_TYPE)
#endif
#ifdef HAVE__BRK
   BRK_IMPL(BRK_RET_TYPE, _brk, BRK_ARG_TYPE)
#endif

#ifdef HAVE___SBRK
   SBRK_IMPL(SBRK_RET_TYPE, __sbrk, SBRK_ARG_TYPE)
#endif
#ifdef HAVE___BRK
   BRK_IMPL(BRK_RET_TYPE, __brk, BRK_ARG_TYPE)
#endif

static int
check_malloc(int size)
{
    char *p = (char *) malloc(size);
    if (!heap_start || !heap_end) return 0;
    if (!p) return 0;
    if (p < heap_start || heap_end <= p) return 0;
    if (p + size < heap_start || heap_end < p + size) return 0;
    return 1;
}

#ifdef ETHR_PTHREADS
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
#endif

static void *
do_tests(void *vresp)
{
    int i, ok = 0;
#ifdef ETHR_PTHREADS
    if (pthread_mutex_lock(&mutex) != 0)
	return NULL;
#endif

    for (i = 0; i < 10; i++)
	if (!check_malloc(1000))
	    goto failed;
    for (i = 0; i < 100; i++)
	if (!check_malloc(1))
	    goto failed;
    if (!check_malloc(1024*1024+1))
	goto failed;
    if (!check_malloc(10*1024*1024+1))
	goto failed;
    ok = 1;

 failed:
#ifdef ETHR_PTHREADS
    if (pthread_mutex_unlock(&mutex) != 0)
	return NULL;
#endif
    if (ok)
	*((int *) vresp) = 0;
    return NULL;
}


int main(void)
{
    int res[N_THR], i;
#ifdef ETHR_PTHREADS
    pthread_t tid[N_THR];
#endif
#if defined(HAVE_END_SYMBOL)
    heap_start = &end;
#elif defined(HAVE__END_SYMBOL)
    heap_start = &_end;
#endif

#if defined(HAVE_MALLOPT) && defined(M_MMAP_MAX)
    (void) mallopt(M_MMAP_MAX, 0);
#endif

    for (i = 0; i < N_THR; i++)
	res[i] = 1;
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_create(&tid[i], NULL, do_tests, &res[i]) != 0)
	    return 1;
#endif
    (void) do_tests(&res[0]);
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_join(tid[i], NULL) != 0)
	    return 1;
#endif
    for (i = 0; i < N_THR; i++)
	if (res[i])
	    return 1;
    return 0;
}
	],
	    erts_cv_brk_wrappers_can_track_malloc=yes,
	    erts_cv_brk_wrappers_can_track_malloc=no,
	    [
	    case X$erl_xcomp_dlsym_brk_wrappers in
		X) erts_cv_brk_wrappers_can_track_malloc=cross;;
		Xyes|Xno) erts_cv_brk_wrappers_can_track_malloc=$erl_xcomp_dlsym_brk_wrappers;;
		*) AC_MSG_ERROR([Bad erl_xcomp_dlsym_brk_wrappers value: $erl_xcomp_dlsym_brk_wrappers]);;
	    esac
	    ])])
	case $erts_cv_brk_wrappers_can_track_malloc in
	    yes)
		AC_DEFINE(ERTS_BRK_WRAPPERS_CAN_TRACK_MALLOC, 1, \
[Define if sbrk()/brk() wrappers can track malloc()s core memory use]);;
	    cross)
		AC_MSG_WARN([result no guessed because of cross compilation]);;
	    *) ;;
	esac
fi

dnl Restore LIBS
LIBS=$saved_libs
dnl restore CPPFLAGS
CPPFLAGS=$saved_cppflags

case $ARCH in
     x86|amd64)
	AC_DEFINE(ERTS_STRUCTURE_ALIGNED_ALLOC, 1, [Define if structure alignment is enough for allocators. If not defined, 64-bit alignment will be forced.]);;
     *)
	;;
esac

LM_SYS_IPV6
LM_SYS_MULTICAST
ERL_TIME_CORRECTION
AC_CHECK_PROG(M4, m4, m4)


if test X${enable_fp_exceptions} = Xauto ; then
   case $host_os in
   	*linux*)
	      enable_fp_exceptions=no
	      AC_MSG_NOTICE([Floating point exceptions disabled by default on Linux]) ;;
	darwin*)
	      enable_fp_exceptions=no
	      AC_MSG_NOTICE([Floating point exceptions disabled by default on MacOS X]) ;;
	      *)
	      ;;
    esac
fi

if test X${enable_fp_exceptions} = Xauto ; then
   if test X${enable_hipe} = Xyes; then
      enable_fp_exceptions=yes
   else
      enable_fp_exceptions=no
   AC_MSG_NOTICE([Floating point exceptions disabled by default in this configuration])
   fi
fi	 

if test X${enable_fp_exceptions} != Xyes ; then
    AC_DEFINE(NO_FPE_SIGNALS,[],[Define if floating points exceptions are non-existing/not reliable])
    FPE=unreliable
else

    AC_MSG_CHECKING([for unreliable floating point exceptions])


    AC_TRY_RUN([
/* fpe-test.c */
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

#if defined(__clang__) || defined(__llvm__)
#error "Clang/LLVM generates broken code for FP exceptions"
#endif

volatile int erl_fp_exception;

/*
 * We expect a single SIGFPE in this test program.
 * Getting many more indicates an inadequate SIGFPE handler,
 * e.g. using the generic handler on x86.
 */
static void new_fp_exception(void)
{
    if (++erl_fp_exception > 50) {
	fprintf(stderr, "SIGFPE loop detected, bailing out\n");
	exit(1);
    }
}

/* Is there no standard identifier for Darwin/MacOSX ? */
#if defined(__APPLE__) && defined(__MACH__) && !defined(__DARWIN__)
#define __DARWIN__ 1
#endif

/*
 * Implement unmask_fpe() and check_fpe() based on CPU/OS combination
 */

#if (defined(__i386__) || defined(__x86_64__)) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)

static void unmask_x87(void)
{
    unsigned short cw;
    __asm__ __volatile__("fstcw %0" : "=m"(cw));
    cw &= ~(0x01|0x04|0x08);   /* unmask IM, ZM, OM */
    __asm__ __volatile__("fldcw %0" : : "m"(cw));
}

static void unmask_sse2(void)
{
    unsigned int mxcsr;
    __asm__ __volatile__("stmxcsr %0" : "=m"(mxcsr));
    mxcsr &= ~(0x003F|0x0680); /* clear exn flags, unmask OM, ZM, IM (not PM, UM, DM) */
    __asm__ __volatile__("ldmxcsr %0" : : "m"(mxcsr));
}

#if defined(__x86_64__)

static inline int cpu_has_sse2(void) { return 1; }

#else /* !__x86_64__ */

/*
 * Check if an x86-32 processor has SSE2.
 */
static unsigned int xor_eflags(unsigned int mask)
{
    unsigned int eax, edx;

    eax = mask;			/* eax = mask */
    __asm__("pushfl\n\t"
	    "popl %0\n\t"	/* edx = original EFLAGS */
	    "xorl %0, %1\n\t"	/* eax = mask ^ EFLAGS */
	    "pushl %1\n\t"
	    "popfl\n\t"		/* new EFLAGS = mask ^ original EFLAGS */
	    "pushfl\n\t"
	    "popl %1\n\t"	/* eax = new EFLAGS */
	    "xorl %0, %1\n\t"	/* eax = new EFLAGS ^ old EFLAGS */
	    "pushl %0\n\t"
	    "popfl"		/* restore original EFLAGS */
	    : "=d"(edx), "=a"(eax)
	    : "1"(eax));
    return eax;
}

static __inline__ unsigned int cpuid_eax(unsigned int op)
{
    unsigned int eax, save_ebx;

    /* In PIC mode i386 reserves EBX. So we must save
       and restore it ourselves to not upset gcc. */
    __asm__(
	"movl %%ebx, %1\n\t"
	"cpuid\n\t"
	"movl %1, %%ebx"
	: "=a"(eax), "=m"(save_ebx)
	: "0"(op)
	: "cx", "dx");
    return eax;
}

static __inline__ unsigned int cpuid_edx(unsigned int op)
{
    unsigned int eax, edx, save_ebx;
 
    /* In PIC mode i386 reserves EBX. So we must save
       and restore it ourselves to not upset gcc. */
    __asm__(
	"movl %%ebx, %2\n\t"
	"cpuid\n\t"
	"movl %2, %%ebx"
	: "=a"(eax), "=d"(edx), "=m"(save_ebx)
	: "0"(op)
	: "cx");
    return edx;
}

/* The AC bit, bit #18, is a new bit introduced in the EFLAGS
 * register on the Intel486 processor to generate alignment
 * faults. This bit cannot be set on the Intel386 processor.
 */
static __inline__ int is_386(void)
{
    return ((xor_eflags(1<<18) >> 18) & 1) == 0;
}

/* Newer x86 processors have a CPUID instruction, as indicated by
 * the ID bit (#21) in EFLAGS being modifiable.
 */
static __inline__ int has_CPUID(void)
{
    return (xor_eflags(1<<21) >> 21) & 1;
}

static int cpu_has_sse2(void)
{
    unsigned int maxlev, features;
    static int has_sse2 = -1;

    if (has_sse2 >= 0)
	return has_sse2;
    has_sse2 = 0;

    if (is_386())
	return 0;
    if (!has_CPUID())
	return 0;
    maxlev = cpuid_eax(0);
    /* Intel A-step Pentium had a preliminary version of CPUID.
       It also didn't have SSE2. */
    if ((maxlev & 0xFFFFFF00) == 0x0500)
	return 0;
    /* If max level is zero then CPUID cannot report any features. */
    if (maxlev == 0)
	return 0;
    features = cpuid_edx(1);
    has_sse2 = (features & (1 << 26)) != 0;

    return has_sse2;
}
#endif /* !__x86_64__ */

static void unmask_fpe(void)
{
    unmask_x87();
    if (cpu_has_sse2())
	unmask_sse2();
}

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("fwait" : "=m"(erl_fp_exception) : "m"(f));
    if (!erl_fp_exception)
       return 0;
    __asm__ __volatile__("fninit");
    unmask_fpe();
    return 1;
}

#elif defined(__sparc__) && defined(__linux__)

#if defined(__arch64__)
#define LDX "ldx"
#define STX "stx"
#else
#define LDX "ld"
#define STX "st"
#endif

static void unmask_fpe(void)
{
    unsigned long fsr;

    __asm__(STX " %%fsr, %0" : "=m"(fsr));
    fsr &= ~(0x1FUL << 23);	/* clear FSR[TEM] field */
    fsr |= (0x1AUL << 23);	/* enable NV, OF, DZ exceptions */
    __asm__ __volatile__(LDX " %0, %%fsr" : : "m"(fsr));
}

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("" : "=m"(erl_fp_exception) : "em"(f));
    return erl_fp_exception;
}

#elif (defined(__powerpc__) && defined(__linux__)) || (defined(__ppc__) && defined(__DARWIN__))

#if defined(__linux__)

#include <sys/prctl.h>

static void set_fpexc_precise(void)
{
    if (prctl(PR_SET_FPEXC, PR_FP_EXC_PRECISE) < 0) {
	perror("PR_SET_FPEXC");
	exit(1);
    }
}

#elif defined(__DARWIN__)

#include <mach/mach.h>
#include <pthread.h>

/*
 * FE0 FE1	MSR bits
 *  0   0	floating-point exceptions disabled
 *  0   1	floating-point imprecise nonrecoverable
 *  1   0	floating-point imprecise recoverable
 *  1   1	floating-point precise mode
 *
 * Apparently:
 * - Darwin 5.5 (MacOS X <= 10.1) starts with FE0 == FE1 == 0,
 *   and resets FE0 and FE1 to 0 after each SIGFPE.
 * - Darwin 6.0 (MacOS X 10.2) starts with FE0 == FE1 == 1,
 *   and does not reset FE0 or FE1 after a SIGFPE.
 */
#define FE0_MASK	(1<<11)
#define FE1_MASK	(1<<8)

/* a thread cannot get or set its own MSR bits */
static void *fpu_fpe_enable(void *arg)
{
    thread_t t = *(thread_t*)arg;
    struct ppc_thread_state state;
    unsigned int state_size = PPC_THREAD_STATE_COUNT;

    if (thread_get_state(t, PPC_THREAD_STATE, (natural_t*)&state, &state_size) != KERN_SUCCESS) {
	perror("thread_get_state");
	exit(1);
    }
    if ((state.srr1 & (FE1_MASK|FE0_MASK)) != (FE1_MASK|FE0_MASK)) {
#if 0
	/* This would also have to be performed in the SIGFPE handler
	   to work around the MSR reset older Darwin releases do. */
	state.srr1 |= (FE1_MASK|FE0_MASK);
	thread_set_state(t, PPC_THREAD_STATE, (natural_t*)&state, state_size);
#else
	fprintf(stderr, "srr1 == 0x%08x, your Darwin is too old\n", state.srr1);
	exit(1);
#endif
    }
    return NULL; /* Ok, we appear to be on Darwin 6.0 or later */
}

static void set_fpexc_precise(void)
{
    thread_t self = mach_thread_self();
    pthread_t enabler;

    if (pthread_create(&enabler, NULL, fpu_fpe_enable, &self)) {
	perror("pthread_create");
    } else if (pthread_join(enabler, NULL)) {
	perror("pthread_join");
    }
}

#endif

static void set_fpscr(unsigned int fpscr)
{
    union {
	double d;
	unsigned int fpscr[2];
    } u;
    u.fpscr[0] = 0xFFF80000;
    u.fpscr[1] = fpscr;
    __asm__ __volatile__("mtfsf 255,%0" : : "f"(u.d));
}

static void unmask_fpe(void)
{
    set_fpexc_precise();
    set_fpscr(0x80|0x40|0x10);	/* VE, OE, ZE; not UE or XE */
}

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("" : "=m"(erl_fp_exception) : "fm"(f));
    return erl_fp_exception;
}

#else

#include <ieeefp.h>

#define unmask_fpe()   fpsetmask(FP_X_INV | FP_X_OFL | FP_X_DZ)

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("" : "=m"(erl_fp_exception) : "g"(f));
    return erl_fp_exception;
}

#endif

/*
 * Implement SIGFPE handler based on CPU/OS combination
 */

#if (defined(__linux__) && (defined(__i386__) || defined(__x86_64__) || defined(__sparc__) || defined(__powerpc__))) || (defined(__DARWIN__) && (defined(__i386__) || defined(__x86_64__) || defined(__ppc__))) || (defined(__FreeBSD__) && (defined(__i386__) || defined(__x86_64__))) || ((defined(__OpenBSD__) || defined(__NetBSD__)) && defined(__x86_64__)) || (defined(__sun__) && defined(__x86_64__))

#if defined(__linux__) && defined(__i386__)
#if !defined(X86_FXSR_MAGIC)
#define X86_FXSR_MAGIC 0x0000
#endif
#elif defined(__FreeBSD__) && defined(__i386__)
#include <sys/types.h>
#include <machine/npx.h>
#elif defined(__FreeBSD__) && defined(__x86_64__)
#include <sys/types.h>
#include <machine/fpu.h>
#elif defined(__DARWIN__)
#include <machine/signal.h>
#elif defined(__OpenBSD__) && defined(__x86_64__)
#include <sys/types.h>
#include <machine/fpu.h>
#endif
#if !(defined(__OpenBSD__) && defined(__x86_64__))
#include <ucontext.h>
#endif
#include <string.h>

static void fpe_sig_action(int sig, siginfo_t *si, void *puc)
{
    ucontext_t *uc = puc;
#if defined(__linux__)
#if defined(__x86_64__)
    mcontext_t *mc = &uc->uc_mcontext;
    fpregset_t fpstate = mc->fpregs;
    fpstate->mxcsr = 0x1F80;
    fpstate->swd &= ~0xFF;
#elif defined(__i386__)
    mcontext_t *mc = &uc->uc_mcontext;
    fpregset_t fpstate = mc->fpregs;
    if ((fpstate->status >> 16) == X86_FXSR_MAGIC)
	((struct _fpstate*)fpstate)->mxcsr = 0x1F80;
    fpstate->sw &= ~0xFF;
#elif defined(__sparc__) && defined(__arch64__)
    /* on SPARC the 3rd parameter points to a sigcontext not a ucontext */
    struct sigcontext *sc = (struct sigcontext*)puc;
    sc->sigc_regs.tpc = sc->sigc_regs.tnpc;
    sc->sigc_regs.tnpc += 4;
#elif defined(__sparc__)
    /* on SPARC the 3rd parameter points to a sigcontext not a ucontext */
    struct sigcontext *sc = (struct sigcontext*)puc;
    sc->si_regs.pc = sc->si_regs.npc;
    sc->si_regs.npc = (unsigned long)sc->si_regs.npc + 4;
#elif defined(__powerpc__)
#if defined(__powerpc64__)
    mcontext_t *mc = &uc->uc_mcontext;
    unsigned long *regs = &mc->gp_regs[0];
#else
    mcontext_t *mc = uc->uc_mcontext.uc_regs;
    unsigned long *regs = &mc->gregs[0];
#endif
    regs[PT_NIP] += 4;
    regs[PT_FPSCR] = 0x80|0x40|0x10;	/* VE, OE, ZE; not UE or XE */
#endif
#elif defined(__DARWIN__)
#if defined(DARWIN_MODERN_MCONTEXT)
#if defined(__x86_64__)
    mcontext_t mc = uc->uc_mcontext;
    struct __darwin_x86_float_state64 *fpstate = &mc->__fs;
    fpstate->__fpu_mxcsr = 0x1F80;
    *(unsigned short *)&fpstate->__fpu_fsw &= ~0xFF;
#elif defined(__i386__)
    mcontext_t mc = uc->uc_mcontext;
    struct __darwin_i386_float_state *fpstate = &mc->__fs;
    fpstate->__fpu_mxcsr = 0x1F80;
    *(unsigned short *)&fpstate->__fpu_fsw &= ~0xFF;
#elif defined(__ppc__)
    mcontext_t mc = uc->uc_mcontext;
    mc->ss.srr0 += 4;
    mc->fs.fpscr = 0x80|0x40|0x10;
#endif
#else
#if defined(__x86_64__)
    mcontext_t mc = uc->uc_mcontext;
    struct x86_float_state64_t *fpstate = &mc->fs;
    fpstate->fpu_mxcsr = 0x1F80;
    *(unsigned short *)&fpstate->fpu_fsw &= ~0xFF;
#elif defined(__i386__)
    mcontext_t mc = uc->uc_mcontext;
    x86_float_state32_t	*fpstate = &mc->fs;
    fpstate->fpu_mxcsr = 0x1F80;
    *(unsigned short *)&fpstate->fpu_fsw &= ~0xFF;
#elif defined(__ppc__)
    mcontext_t mc = uc->uc_mcontext;
    mc->ss.srr0 += 4;
    mc->fs.fpscr = 0x80|0x40|0x10;
#endif
#endif
#elif defined(__FreeBSD__) && defined(__x86_64__)
    mcontext_t *mc = &uc->uc_mcontext;
    struct savefpu *savefpu = (struct savefpu*)&mc->mc_fpstate;
    struct envxmm *envxmm = &savefpu->sv_env;
    envxmm->en_mxcsr = 0x1F80;
    envxmm->en_sw &= ~0xFF;
#elif defined(__FreeBSD__) && defined(__i386__)
    mcontext_t *mc = &uc->uc_mcontext;
    union savefpu *savefpu = (union savefpu*)&mc->mc_fpstate;
    if (mc->mc_fpformat == _MC_FPFMT_XMM) {
	struct envxmm *envxmm = &savefpu->sv_xmm.sv_env;
	envxmm->en_mxcsr = 0x1F80;
	envxmm->en_sw &= ~0xFF;
    } else {
	struct env87 *env87 = &savefpu->sv_87.sv_env;
	env87->en_sw &= ~0xFF;
    }
#elif defined(__OpenBSD__) && defined(__x86_64__)
    struct fxsave64 *fxsave = uc->sc_fpstate;
    fxsave->fx_mxcsr = 0x1F80;
    fxsave->fx_fsw &= ~0xFF;
#elif defined(__NetBSD__) && defined(__x86_64__)
    mcontext_t *mc = &uc->uc_mcontext;
    struct fxsave64 *fxsave = (struct fxsave64 *)&mc->__fpregs;
    fxsave->fx_mxcsr = 0x1F80;
    fxsave->fx_fsw &= ~0xFF;
#elif defined(__sun__) && defined(__x86_64__)
    mcontext_t *mc = &uc->uc_mcontext;
    struct fpchip_state *fpstate = &mc->fpregs.fp_reg_set.fpchip_state;
    fpstate->mxcsr = 0x1F80;
    fpstate->sw &= ~0xFF;
#endif
    new_fp_exception();
}

static void catch_sigfpe(void)
{
    struct sigaction act;

    memset(&act, 0, sizeof act);
    act.sa_sigaction = fpe_sig_action;
    act.sa_flags = SA_SIGINFO;
    sigaction(SIGFPE, &act, NULL);
}

#else

static void fpe_sig_handler(int sig)
{
    new_fp_exception();
}

static void catch_sigfpe(void)
{
    signal(SIGFPE, fpe_sig_handler);
}

#endif

/*
 * Generic test code
 */

static void do_init(void)
{
    catch_sigfpe();
    unmask_fpe();
}

double a = 3.23e133;
double b = 3.57e257;
double res;

void do_fmul(void)
{
    res = a * b;
}

int do_check(void)
{
    if (check_fpe(res)) {
       fprintf(stderr, "res = %g, FPE worked\n", res);
       return 0;
    } else {
       fprintf(stderr, "res = %g, FPE failed\n", res);
       return 1;
    }
}

int main(int argc, const char **argv)
{
    if (argc == 3) {
       a = atof(argv[1]);
       b = atof(argv[2]);
    }
    do_init();
    do_fmul();
    return do_check();
}
],
erl_ok=yes,
erl_ok=no,
[
case X$erl_xcomp_reliable_fpe in
    X) erl_ok=cross;;
    Xyes|Xno) erl_ok=$erl_xcomp_reliable_fpe;;
    *) AC_MSG_ERROR([Bad erl_xcomp_reliable_fpe value: $erl_xcomp_reliable_fpe]);;
esac
])

    if test $erl_ok = yes; then
	FPE=reliable
        AC_MSG_RESULT(reliable)
    else
	FPE=unreliable
	AC_MSG_RESULT([unreliable; testing in software instead])
	AC_DEFINE(NO_FPE_SIGNALS,[],[Define if floating points exceptions are non-existing/not reliable])
	if test $erl_ok = cross; then
	    AC_MSG_WARN([result unreliable guessed because of cross compilation])
	fi
    fi
fi	

AC_SUBST(FPE)


dnl
dnl Some operating systems allow you to redefine FD_SETSIZE to be able
dnl to select on more than the default number of file descriptors.
dnl We first discovered this in BSD/OS where the default is ridiculously
dnl low (256). But since we use a lot of file descriptors we found the
dnl need to go over the limit in other os's as well. Since FD_SETSIZE 
dnl must be defined before pulling in sys/types.h the actual number
dnl of file descriptors is set in acconfig.h and will thus be in config.h
dnl which *always* should be included first.
dnl

AC_MSG_CHECKING([whether to redefine FD_SETSIZE])
case $host_os in
  bsdi*)
	AC_DEFINE(REDEFINE_FD_SETSIZE,[],[Define if you wish to redefine FD_SETSIZE to be able to select on more fd])
	AC_MSG_RESULT(yes)
	;;
  *)
	AC_MSG_RESULT(no)
	;;
esac



dnl ----------------------------------------------------------------------
dnl Tests related to configurable options given on command line
dnl (using the --disable, --enable and --with switches).
dnl ----------------------------------------------------------------------

#
# Check for working poll().
#
AC_MSG_CHECKING([for working poll()])
if test "x$ac_cv_header_poll_h" != "xyes" -o "x$ac_cv_func_poll" != "xyes"; then

poll_works=no

else

AC_TRY_RUN([
#include <poll.h>
main()
{
#ifdef _POLL_EMUL_H_
  exit(1); /* Implemented using select() -- fail */
#else
  struct pollfd fds[1];
  int fd;
  fd = open("/dev/null", 1);
  fds[0].fd = fd;
  fds[0].events = POLLIN;
  fds[0].revents = 0;
  if (poll(fds, 1, 0) < 0 || (fds[0].revents & POLLNVAL) != 0) {
    exit(1);  /* Does not work for devices -- fail */
  }
  exit(0);
#endif
}
],
poll_works=yes,
poll_works=no,
[
case X$erl_xcomp_poll in
    X) poll_works=cross;;
    Xyes|Xno) poll_works=$erl_xcomp_poll;;
    *) AC_MSG_ERROR([Bad erl_xcomp_poll value: $erl_xcomp_poll]);;
esac
])

fi

case $poll_works-$host_os in
    no-*|cross-darwin*)
	#
	# The USE_SELECT define is used by the ssl application (should not
	# be used by erts).
	#
	AC_DEFINE(USE_SELECT, 1, [Define if select() should be used instead of poll()])
	if test $poll_works = cross; then
	    AC_MSG_RESULT(cross)
	    AC_MSG_WARN([result no guessed based on OS ($host_os) because of cross compilation])
	else
	    AC_MSG_RESULT([no; non-existing, broken, or based on select()])
        fi
	poll_works=no;;
    yes-*|cross-*)
	AC_DEFINE(ERTS_USE_POLL, 1, [Define if poll() should be used instead of select()])
	if test $poll_works = cross; then
	    AC_MSG_RESULT(cross)
	    AC_MSG_WARN([result yes guessed based on OS ($host_os) because of cross compilation])
	else
	    AC_MSG_RESULT(yes)
        fi
	poll_works=yes;;
esac

#
# If kqueue() found
#
if test $have_kernel_poll = kqueue; then
## Some OS X kernel version seems to have bugs in them with regards to kqueue
## Disable kernel poll on those versions
   AC_MSG_CHECKING([whether host os has known kqueue bugs])
   case $host_os in
     # Any OS X version < 16 has known problems with using kqueue
     # so we don't use it there. See erl_poll.c for details.
     darwin[[0-9]].*|darwin1[[0-5]].*)
        AC_MSG_RESULT([yes, disabling kernel poll])
        have_kernel_poll=no
        ;;
     *)
        AC_MSG_RESULT([no])
        ;;
   esac
fi
#
# If epoll() found, check that it is level triggered.
#
if test $have_kernel_poll = epoll; then
	AC_MSG_CHECKING([whether epoll is level triggered])
	AC_TRY_LINK([#include <sys/epoll.h>],[
			#ifdef EPOLLET
			/* Edge triggered option exist, assume level triggered
			   is default */
			;
			#else
			/* No edge triggered option exist; assume edge
			   triggered only */
			#error No EPOLLET
			#endif
			],
			level_triggered_epoll=yes,
			[level_triggered_epoll=no
			 have_kernel_poll=no])
	AC_MSG_RESULT([$level_triggered_epoll])
fi
#
# Check if we should enable kernel poll support
#
AC_MSG_CHECKING(whether kernel poll support should be enabled)
ERTS_ENABLE_KERNEL_POLL=no
ERTS_BUILD_FALLBACK_POLL=no
case $enable_kernel_poll-$have_kernel_poll in
    no-*)
	AC_MSG_RESULT(no; disabled by user);;
    yes-no)
	AC_MSG_ERROR(no; kernel poll support requested but not found);;
    *-no)
	AC_MSG_RESULT(no);;
    *)
	case $have_kernel_poll in
	    epoll)
		AC_DEFINE(HAVE_SYS_EPOLL_H, 1, [Define if you have the <sys/epoll.h> header file.])
                ERTS_BUILD_FALLBACK_POLL=yes
                ;;
	    /dev/poll)
		AC_DEFINE(HAVE_SYS_DEVPOLL_H, 1, [Define if you have <sys/devpoll.h> header file.])
                ;;
	    kqueue)
		AC_DEFINE(HAVE_SYS_EVENT_H, 1, [Define if you have <sys/event.h> header file.])
                ERTS_BUILD_FALLBACK_POLL=yes
                ;;
	    *)
		AC_MSG_ERROR(configure.in need to be updated);;
	esac
	ERTS_ENABLE_KERNEL_POLL=yes
	AC_DEFINE(ERTS_ENABLE_KERNEL_POLL, 1, [Define if you have kernel poll and want to use it])
	AC_MSG_RESULT([yes; $have_kernel_poll]);;
esac
AC_SUBST(ERTS_BUILD_FALLBACK_POLL)

AC_MSG_CHECKING([whether putenv() stores a copy of the key-value pair])
AC_TRY_RUN([
#include <stdlib.h>
int main(void) {
    int i;
    char *env;
    char buf[10];
    for (i = 0; i < 7; i++)
	buf[i] = 'X';
    buf[i] = '\0';
    buf[3] = '=';
    if (putenv(buf) != 0)
	return 1;
    for (i = 4; i < 7; i++)
	buf[i] = 'Y';
    env = getenv("XXX");
    if (!env)
	return 2;
    for (i = 0; i < 3; i++)
	if (env[i] != 'X')
	    return 3;
    for (i = 0; i < 3; i++)
	buf[i] = 'Y';
    env = getenv("XXX");
    if (!env)
	return 4;
    for (i = 0; i < 3; i++)
	if (env[i] != 'X')
	    return 5;
    return 0;
}
],
copying_putenv=yes,
copying_putenv=no,
[
case X$erl_xcomp_putenv_copy in
    X) copying_putenv=cross;;
    Xyes|Xno) copying_putenv=$erl_xcomp_putenv_copy;;
    *) AC_MSG_ERROR([Bad erl_xcomp_putenv_copy value: $erl_xcomp_putenv_copy]);;
esac
])

AC_MSG_RESULT($copying_putenv)
case $copying_putenv in
    yes)
	AC_DEFINE(HAVE_COPYING_PUTENV,[1],\
[Define if you have a putenv() that stores a copy of the key-value pair]);;
    cross)
	AC_MSG_WARN([result no guessed because of cross compilation]);;
    *) ;;
esac

dnl ----------------------------------------------------------------------
dnl Stuff that should be moved into their respective application
dnl ----------------------------------------------------------------------

dnl crypto
#--------------------------------------------------------------------
# Dynamic Erlang Drivers
#
# Linking to produce dynamic Erlang drivers to be loaded by Erlang's
# Dynamic Driver Loader and Linker (DDLL). Below the prefix DED is an
# abbreviation for `Dynamic Erlang Driver'.
#
# For DED we need something quite sloppy, which allows undefined references 
# (notably driver functions) in the resulting shared library. 
# Example of Makefile rule (and settings of macros):
#
# LIBS = @LIBS@
# LD = @DED_LD@
# LDFLAGS = @DED_LDFLAGS@
# soname = @ldsoname@
#
# my_drv.so:   my_drv.o my_utils.o
#              $(LD) $(LDFLAGS) $(soname) $@ -o $@ $^ -lc $(LIBS)
#
#--------------------------------------------------------------------

DED_SYS_INCLUDE="-I${ERL_TOP}/erts/emulator/beam -I${ERL_TOP}/erts/include -I${ERL_TOP}/erts/include/$host -I${ERL_TOP}/erts/include/internal -I${ERL_TOP}/erts/include/internal/$host -I${ERL_TOP}/erts/emulator/sys/$ERLANG_OSTYPE -I${ERL_TOP}/erts/emulator/sys/common"

if test "X$ETHR_DEFS" = "X"; then
    DED_THR_DEFS="-D_THREAD_SAFE -D_REENTRANT"
else
    DED_THR_DEFS="$ETHR_DEFS"
fi
DED_EMU_THR_DEFS=$EMU_THR_DEFS
DED_CFLAGS="$CFLAGS $CPPFLAGS"
if test "x$GCC" = xyes; then
    DED_STATIC_CFLAGS="$DED_CFLAGS"
    DED_CFLAGS="$DED_CFLAGS -fPIC"
fi

DED_EXT=so
case $host_os in
    win32) DED_EXT=dll;;
    darwin*)
	DED_CFLAGS="$DED_CFLAGS -fno-common"
	DED_STATIC_CFLAGS="$DED_STATIC_CFLAGS -fno-common";;
    *)
	;;
esac

DED_STATIC_CFLAGS="$DED_STATIC_CFLAGS -DSTATIC_ERLANG_NIF -DSTATIC_ERLANG_DRIVER"

# If DED_LD is set in environment, we expect all DED_LD* variables
# to be specified (cross compiling)
if test "x$DED_LD" = "x"; then

DED_LD_FLAG_RUNTIME_LIBRARY_PATH="-R"
case $host_os in
	win32)
		DED_LD="ld.sh"
		DED_LDFLAGS="-dll"
		DED_LD_FLAG_RUNTIME_LIBRARY_PATH=
	;;
	solaris2*|sysv4*)
		DED_LDFLAGS="-G"
		if test X${enable_m64_build} = Xyes; then
			DED_LDFLAGS="-64 $DED_LDFLAGS"
		fi
	;;
	aix4*)
		DED_LDFLAGS="-G -bnoentry -bexpall"
	;;
	freebsd2*)
		# Non-ELF GNU linker
		DED_LDFLAGS="-Bshareable"
	;;
	darwin*)
		# Mach-O linker: a shared lib and a loadable
		# object file is not the same thing.
		DED_LDFLAGS="-bundle -bundle_loader ${ERL_TOP}/bin/$host/beam.smp"
		case $ARCH in
			amd64)
				DED_LDFLAGS="-m64 $DED_LDFLAGS"
				;;
			*)
				;;
		esac
		DED_LD="$CC"
		DED_LD_FLAG_RUNTIME_LIBRARY_PATH="$CFLAG_RUNTIME_LIBRARY_PATH"
	;;
	linux*)
		DED_LD="$CC"
		DED_LD_FLAG_RUNTIME_LIBRARY_PATH="$CFLAG_RUNTIME_LIBRARY_PATH"
		DED_LDFLAGS="-shared -Wl,-Bsymbolic"
		if test X${enable_m64_build} = Xyes; then
			DED_LDFLAGS="-m64 $DED_LDFLAGS"
		fi;
		if test X${enable_m32_build} = Xyes; then
			DED_LDFLAGS="-m32 $DED_LDFLAGS"
		fi
	;;	
	freebsd*)
		DED_LD="$CC"
		DED_LD_FLAG_RUNTIME_LIBRARY_PATH="$CFLAG_RUNTIME_LIBRARY_PATH"
		DED_LDFLAGS="-shared"
		if test X${enable_m64_build} = Xyes; then
			DED_LDFLAGS="-m64 $DED_LDFLAGS"
		fi;
		if test X${enable_m32_build} = Xyes; then
			DED_LDFLAGS="-m32 $DED_LDFLAGS"
		fi
	;;	
	openbsd*)
		DED_LD="$CC"
		DED_LD_FLAG_RUNTIME_LIBRARY_PATH="$CFLAG_RUNTIME_LIBRARY_PATH"
		DED_LDFLAGS="-shared"
	;;
	osf*)
		# NOTE! Whitespace after -rpath is important.
		DED_LD_FLAG_RUNTIME_LIBRARY_PATH="-rpath "
		DED_LDFLAGS="-shared -expect_unresolved '*'"
	;;
	*)
		# assume GNU linker and ELF
		DED_LDFLAGS="-shared"
		# GNU linker has no option for 64bit build, should not propagate -m64
	;;
esac

if test "$DED_LD" = "" && test "$USER_LD" != ""; then
    DED_LD="$USER_LD"
    DED_LDFLAGS="$USER_LDFLAGS $DED_LDFLAGS"
fi

fi # "x$DED_LD" = "x"

AC_CHECK_TOOL(DED_LD, ld, false)
test "$DED_LD" != "false" || AC_MSG_ERROR([No linker found])

AC_MSG_CHECKING(for compiler flags for loadable drivers)
AC_MSG_RESULT([$DED_CFLAGS])
AC_MSG_CHECKING(for linker for loadable drivers)
AC_MSG_RESULT([$DED_LD])
AC_MSG_CHECKING(for linker flags for loadable drivers)
AC_MSG_RESULT([$DED_LDFLAGS])
AC_MSG_CHECKING(for 'runtime library path' linker flag)
if test "x$DED_LD_FLAG_RUNTIME_LIBRARY_PATH" != "x"; then
	AC_MSG_RESULT([$DED_LD_FLAG_RUNTIME_LIBRARY_PATH])
else
	AC_MSG_RESULT([not found])
fi

AC_SUBST(DED_EXT)
AC_SUBST(DED_SYS_INCLUDE)
AC_SUBST(DED_CFLAGS)
AC_SUBST(DED_STATIC_CFLAGS)
AC_SUBST(DED_LD)
AC_SUBST(DED_LDFLAGS)
AC_SUBST(DED_LD_FLAG_RUNTIME_LIBRARY_PATH)
AC_SUBST(DED_THR_DEFS)
AC_SUBST(DED_EMU_THR_DEFS)
AC_SUBST(STATIC_CFLAGS)

dnl
dnl We should look for a compiler that handles jump tables, for beam_emu 
dnl to be optimized
dnl

LM_FIND_EMU_CC

dnl
dnl Test whether code pointers are always short (32 bits).
dnl

AC_MSG_CHECKING([whether the code model is small])
saved_LDFLAGS="$LDFLAGS"
LDFLAGS="$LDFLAGS $HIPEBEAMLDFLAGS"
AC_TRY_RUN([
   #include <stdlib.h>
   int main() {
    if ((unsigned long long)&main < (1ull << 32)) {
       exit(0);
    }
    exit(1);
   }
],
erl_code_model_small=yes,
erl_code_model_small=no,
erl_code_model_small=no)
AC_MSG_RESULT([$erl_code_model_small])
LDFLAGS="$saved_LDFLAGS"
case $erl_code_model_small in
     yes)
        AC_DEFINE(CODE_MODEL_SMALL,[1],
	[Define if the code model is small (code fits below 2Gb)])
	CODE_MODEL=small
	;;
     no)
	CODE_MODEL=unknown
        ;;
esac
AC_SUBST(CODE_MODEL)

AC_ARG_WITH(javac,
AS_HELP_STRING([--with-javac=JAVAC], [specify Java compiler to use])
AS_HELP_STRING([--with-javac], [use a Java compiler if found (default)])
AS_HELP_STRING([--without-javac], [don't use any Java compiler]))

dnl
dnl Then there are a number of apps which needs a java compiler...
dnl
need_java="jinterface ic/java_src"

# Remove all SKIP files from previous runs
for a in $need_java ; do
  $RM -f $ERL_TOP/lib/$a/SKIP
done

if test "X$with_javac" = "Xno"; then
  for a in $need_java ; do
	echo "Java compiler disabled by user" > $ERL_TOP/lib/$a/SKIP
  done

else # begin - try to find javac

if test "X$with_javac" != "Xyes" -a "X$with_javac" != "X"; then
    check_javac=$with_javac
else
  check_javac="javac.sh javac guavac gcj jikes bock"
fi

AC_CHECK_PROGS(JAVAC, $check_javac)
if test -n "$JAVAC"; then
  dnl Make sure it's at least JDK 1.6
  AC_CACHE_CHECK(for JDK version 1.6, 
     ac_cv_prog_javac_ver_1_6,
     [ERL_TRY_LINK_JAVA([], [for (String i : args);],
        ac_cv_prog_javac_ver_1_6=yes, ac_cv_prog_javac_ver_1_6=no)])
  if test $ac_cv_prog_javac_ver_1_6 = no; then
    unset -v JAVAC
  fi
fi
if test -z "$JAVAC"; then

  if test "X$with_javac" != "X"; then
  	AC_MSG_ERROR([No java compiler found in PATH (checked for $check_javac)])
  fi

  AC_MSG_WARN([Could not find any usable java compiler, will skip: jinterface])

  for a in $need_java ; do
	echo "No Java compiler found" > $ERL_TOP/lib/$a/SKIP
  done
fi

fi # end - try to find javac

dnl
dnl Orber has a c++ example, this isn't the right way to check for
dnl it, but....
dnl
AC_SUBST(CXXFLAGS)
dnl this deliberately does not believe that 'gcc' is a C++ compiler
AC_CHECK_TOOLS(CXX, [$CCC c++ g++ CC cxx cc++ cl], false)

# Remove SKIP file from previous run
$RM -f $ERL_TOP/lib/orber/SKIP

if test "$CXX" = false; then
  echo "No C++ compiler found" > $ERL_TOP/lib/orber/SKIP
fi

dnl ----------------------------------------------------------------------
dnl Include CPPFLAGS in CFLAGS
dnl ----------------------------------------------------------------------
CFLAGS="$CFLAGS $CPPFLAGS"

#
# Currently if we compile for 64 bits we want to compile
# some external port programs using 32 bits
#

# If not defined we trust the C compiler in $CC to do 32 bits
if test -z "$CC32"; then
  CC32="$CC"
fi

if test -z "$CFLAGS32"; then
  if test $ac_cv_sizeof_void_p != 4; then
    # We are compiling default 64 bits and use -m32 for 32 bit compilations
    CFLAGS32="$CFLAGS -m32"
  else
    CFLAGS32="$CFLAGS"
  fi
fi

AC_SUBST(CC32)
AC_SUBST(CFLAGS32)

dnl
dnl ERTS_EMU_CMDLINE_FLAGS will force modification of config.h when
dnl the emulator command line flags are modified by configure, which
dnl in turn will make 'make' detect that files depending on config.h
dnl needs to be rebuilt.
dnl

AC_DEFINE_UNQUOTED(ERTS_EMU_CMDLINE_FLAGS,
"$STATIC_CFLAGS $CFLAGS $DEBUG_CFLAGS $EMU_THR_DEFS $DEFS $WERRORFLAGS $WFLAGS",
[The only reason ERTS_EMU_CMDLINE_FLAGS exists is to force modification of config.h when the emulator command line flags are modified by configure])

dnl ----------------------------------------------------------------------
dnl Directories needed for the build LATH ????
dnl ----------------------------------------------------------------------

erts=${erl_top}/erts

erts_dirs="								
  $erts/obj $erts/obj.debug
									
  $erts/obj/$host
  $erts/obj.debug/$host

"
for d in ${erl_top}/bin ${erl_top}/bin/$host $erts_dirs ;
do
  if test ! -d $d; then
    mkdir -p 1>/dev/null 2>&1 $d
  fi
done

dnl ---------------------------------------------------------------------
dnl Autoheader macro for adding code at top and bottom of config.h.in
dnl ---------------------------------------------------------------------
AH_TOP([
#define GHBN_R_SOLARIS  2
#define GHBN_R_AIX      3
#define GHBN_R_GLIBC    4
])

AH_BOTTOM([
/* Redefine in6_addr. XXX this should be moved to the files where it's used? */
#ifdef HAVE_IN_ADDR6_STRUCT
#define in6_addr in_addr6
#endif

/* Define a reasonable default for INADDR_LOOPBACK */
/* XXX this should be moved to the files where it's used? */
#ifdef HAVE_NO_INADDR_LOOPBACK
#define INADDR_LOOPBACK (u_long)0x7F000001
#endif

#ifdef REDEFINE_FD_SETSIZE
#define FD_SETSIZE 1024
#endif
 
#ifdef HAVE_GETHRVTIME_PROCFS_IOCTL
#define HAVE_GETHRVTIME
#endif

#if !defined(HAVE_ISFINITE) && !defined(HAVE_FINITE)
# if defined(HAVE_ISINF) && defined(HAVE_ISNAN)
#  define USE_ISINF_ISNAN
# endif
#endif

#if defined(DEBUG) && !defined(ERTS_ENABLE_LOCK_CHECK)
#define ERTS_ENABLE_LOCK_CHECK 1
#endif
])

if test "x$GCC" = xyes; then
  CFLAGS="$WERRORFLAGS $CFLAGS"
fi

dnl ----------------------------------------------------------------------
dnl Enable -fsanitize= flags.
dnl ----------------------------------------------------------------------

m4_define(DEFAULT_SANITIZERS, [address,undefined])
AC_ARG_ENABLE(
    sanitizers,
    AS_HELP_STRING(
        [--enable-sanitizers@<:@=comma-separated list of sanitizers@:>@],
	    [Default=DEFAULT_SANITIZERS]),
[
case "$enableval" in
    no) sanitizers= ;;
    yes) sanitizers="-fsanitize=DEFAULT_SANITIZERS" ;;
    *) sanitizers="-fsanitize=$enableval" ;;
esac
CFLAGS="$CFLAGS $sanitizers"
LDFLAGS="$LDFLAGS $sanitizers"
])

dnl ----------------------------------------------------------------------
dnl Check for log2
dnl ----------------------------------------------------------------------
AC_CHECK_FUNCS([log2])

dnl ----------------------------------------------------------------------
dnl Output the result.
dnl ----------------------------------------------------------------------
dnl
dnl The ones below should be moved to their respective lib
dnl
AC_CONFIG_FILES([
  lib/ic/c_src/$host/Makefile:lib/ic/c_src/Makefile.in
  ])

AC_OUTPUT
